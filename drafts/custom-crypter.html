<!DOCTYPE HTML>
<!--
	Solution for SLAE question #7

-->
<html>
	<head>
		<link rel="icon" href="../images/favicon.ico">
		<title>The Post</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<link rel="stylesheet" href="../assets/css/atom-one-dark-reasonable.min.css">
		<script src="../assets/js/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
		<noscript><link rel="stylesheet" href="../assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a class="logo">The Defense</a>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="../index.html">Home</a></li>
							<li class="active"><a href="../posts.html">Posts</a></li>
							<li><a href="../research.html">Research</a></li>
							<li><a href="../stories.html">Stories</a></li>
							<li><a href="../references.html">Links</a></li>
						</ul>
						<ul class="icons">
							<li><a href="mailto:jpc0016@uah.edu" class="icon fa-paper-plane-o" target="_blank"><span class="label">Gmail</span></a></li>
							<li><a href="https://github.com/jpc0016" class="icon fa-github" target="_blank"><span class="label">GitHub</span></a></li>
							<li><a href="https://twitter.com/JohnGuy_01" class="icon fa-twitter" target="_blank"><span class="label">Twitter</span></a></li>
							<li><a href="https://stackoverflow.com/users/11770689/jpc0016?tab=profile" class="icon fa-stack-overflow" target="_blank"><span class="label">StackOverflow</span></a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">
						<div class="wrapper">

						<!-- Post -->

									<!--
									Post body goes here.
									-->
                  <!--
                  Solving slae question 7
                  -->
                  <section class="post">
                    <body>
                      <article id="first-post">
												<a href="index.html"><img src="../images/gus.jpg" class="avatar" alt="avatar"> </img></a>
                        <h2>&emsp; Creating a Custom Crypter</h2>
												<h5>&emsp; &emsp; &emsp; &emsp; December 8, 2020</h5>
                        <div class="box">

													<br><h2>Contents</h2>
													<a href="#POC" style="color:blue;">Drafting the Proof of Concept</a><br>
													<a href="#Outline" style="color:blue;">System Outline</a><br>
													<a href="#Testing" style="color:blue;">Test Methodology</a><br>
													<a href="#Simple" style="color:blue;">Constructing the Simple Functions</a><br>
													<a href="#MixColumns" style="color:blue;">Mix Columns</a><br>
													<a href="#ExpandKey" style="color:blue;">Key Expansion</a><br>
													<a href="#Cipher" style="color:blue;">Cipher Repetitions</a><br>
													<a href="#Integration" style="color:blue;">Integration and Demonstration</a><br>
													<a href="#Thoughts" style="color:blue;">Thoughts and Lessons Learned</a><br><br>

												<p>
														&emsp; &emsp;Good evening Tim and Aaron! &nbsp;The final post is about building a custom crypter that operates on encrypted shellcode to decrypt and
														execute it at runtime. &nbsp;This will be a challenging assignment as crypters are typically above average in size. &nbsp;Much like encoding and
														polymorphism, the purpose of encrypting shellcode is to hide it from defense mechanisms such as AntiVirus (AV) and Intrusion Detection Systems (IDSs).
														 &nbsp;A quick review of encryption is below:<br><br>

														Encryption is a fundamental building block of computer security in which plaintext is scrambled into unreadable form using a key and sometimes
														an Initialization Vector (IV). &nbsp;Scrambling sophistication depends on an encryption scheme's algorithm. &nbsp;Some algorithms have more
														"rounds" of shifting than others. &nbsp;Symmetric encryption will be used in this post. &nbsp;In a symmetric
														algorithm, the key is shared between encryption and decryption functions.
											 	</p>
												<center><div class="image post"><img src="../images/slae/assignment7/1-encryption.png" width="700" alt="" /></div></center><br>

												<p>The above diagram depicts a symmetric encryption/decryption scheme that will be developed in this post. &nbsp;In addition to this graph, the custom
												encoding/decoding scheme from <a href="https://thestunneddefense.com/pages/custom-encoding.html" target="_blank" style="color:blue;">blog post 4</a> will be
												layered into the system. &nbsp;Finally, the payload used will be the familiar <i>execve-stack</i> shellcode used to pop a <i>/bin/sh</i> shell. &nbsp;Below
												 is the final product when everything is tied together.
												</p>
												<center><div class="image post"><img src="../images/slae/assignment7/2-crypter.png" alt="" /></div></center><br>



			<br><section id="POC"><h2>Drafting the Proof of Concept</h2></section>

											<p>
												&emsp; &emsp;Similar to bind and reverse shells, a Proof of Concept (PoC) is developed using a higher level language. &nbsp;The difference this time is
												that no assembly will be coded as a result of the PoCs produced. &nbsp;This is because decryptors require many more assembly instructions
												 than decoders. &nbsp;It is simply infeasable to write a decryptor in x86 assembly when shellcode must often meet a length requirement.<br>
												&emsp; &emsp;Based on the graph above, both an encryptor and decryptor need to be produced. &nbsp;They can be developed in Python or C due to their common
												handling of bytes. &nbsp;Both programs must take a key string as a parameter. &nbsp;Luckily, the decryptor will be similar to the encryptor; just
												backwards! &nbsp;Assignment constraints are below:<br>
												<li>Any existing encryption schema can be used.</li>
												<li>Any programming language can be used.</li><br>
												This is good news as developing a brand new algorithm requires significantly more time. &nbsp;Simply pick an algorithm from the list of encryption schemes
												<a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm#Implementations" target="_blank" style="color:blue;">here</a>
												and choose a langauge comfortable for developing both programs.
											</p>
											<center><div class="image post"><img src="../images/slae/assignment7/3-algorithms.png" alt="" /></div></center><br>

											<p>This project will be written in C to construct an Advanced Encryption Standard (AES) crypter in 128-bit mode. &nbsp;C was selected because the crypter
											operates on bytes of data and C enables more control over 8-bit data types. &nbsp;128-bit mode was selected because it is easier to implement and has more open-source
											 test cases. &nbsp;256-bit mode could be implemented as well; however, along with fewer test cases, 256-bit mode requires key padding based on whichever
											 standard is used (ECB, CBC, CTR, etc.). &nbsp;Padding occurs to ensure the first 32 bytes of key data are filled when operating in 256-bit mode. &nbsp;This
											  is because in 256-bit mode, the first 32 bytes of the key schedule are filled with bytes from the user-provided secret key and padded to meet 32 bytes
												should the key come up short. &nbsp;In contrast, 128-bit mode only requires 16 bytes of the secret key. &nbsp;The next step is determining the general
												makeup of AES then worry about 128-bit specific implementations.
										</p>

			<br><section id="Outline"><h2>System Outline</h2></section>

											<p>
												&emsp; &emsp;Before jumping into any code, it is important to get a strategic view of AES in a systems engineering approach. &nbsp;What are sub-methods are used,
												the data types, input and output, etc? &nbsp;The diagram below
						(<a href="https://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0134444280/ref=sr_1_2?dchild=1&keywords=ISBN+13%3A+978-1-292-15858-7&qid=1606786625&sr=8-2" target="_blank" style="color:blue;">source</a>, pg 178)
												illustrates a much needed breakdown of AES to determine number of functions to write. &nbsp;
											</p>
											<center><div class="image post"><img src="../images/slae/assignment7/4-aes-system.png" alt="" /></div></center><br>

											<p>
												There are ten encryption rounds (for 128-bit mode) made up of four functions in order: <i>Substitute bytes</i>, <i>Shift rows</i>, <i>Mix columns</i>, and
												<i>Add round key</i>. &nbsp;Note that <i>Mix columns</i> is omitted from the final encryption round. &nbsp;A similar removal also occurs in decryption when
												<i>Inverse mix columns</i> is omitted.<br>
												&emsp; &emsp;In addition to the above functions, AES uses a key expansion technique to transform 16 bytes of a user-supplied secret key into 44 words
												(44 words x 4 bytes = 176 bytes) used during encryption rounds. &nbsp;The key expansion algorithm has internal functions of their own and can be observed below
					(<a href="https://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0134444280/ref=sr_1_2?dchild=1&keywords=ISBN+13%3A+978-1-292-15858-7&qid=1606786625&sr=8-2" target="_blank" style="color:blue;">source</a>, pg 191).
											</p>
											<center><div class="image post"><img src="../images/slae/assignment7/5-key-expansion.png" alt="" /></div></center><br>

											<p>
												The 16-byte key is saved in a 4x4 matrix with bytes grouped into words by columns, which may seem counterintuitive to naturally viewing data by rows. &nbsp;Every fourth word group
												is sent through a function called <i>g()</i> which contains subfunctions: <i>Rotate Word</i> and <i>Substitute bytes</i>. &nbsp;The result is XORed by a round constant (RC<sub>j</sub>) in
												the leftmost byte.


											</p>

			<br><section id="Testing"><h2>Test Methodology</h2></section>
											<p>
												&emsp; &emsp;With a general outline in place, the question becomes "where to start?" &nbsp;This much code can be overwhelming if approached haphazardly. &nbsp;One
												strategy is to write one function, preferably a simple one, and pass test values to observe its output. &nbsp;It also helps to know the expected output, which a simple
												function further guarantees. &nbsp;For example, starting with <i>RotWord()</i> (Rotate word) is ideal because it is small, takes fewer input, and its expected output is
												very predictable!<br>
												&emsp; &emsp;Below is an example of testing the <i>SubBytes()</i> function. &nbsp;In practice, this function will take a 16 byte state matrix as input, look up the
												sbox value of each byte, and replace that state matrix byte with its sbox lookup value. &nbsp;Check the returned state matrix by manually looking at the sbox value for each
												byte. &nbsp;Although a bit tedious, it ensures a valid test case which is important when building the remaining program. &nbsp;Specifics of each function will be covered
												later.
											</p>
											<pre>
												<code class="c-like" style=display:block;white-space:pre-wrap>
/************  SAMPLE TEST-BED FOR SINGLE FUNCTION  ************/

// Cipher transformation that processes the state using S-box substitutions
void SubBytes(uint8_t state[4][4]){

    // Execute SubBytes function per 'Ch06 Crypto7e.pdf' pg. 12
    // Each byte is an index of row x column. Ex: 0x95 = row 9, column 5
    int i, j;
    for (i = 0; i&lt;4; i++){
        for (j = 0; j&lt;4; j++){
            // for each byte need to look up sbox at specific index and assign to spot
            state[i][j] = sbox[HI_NIBBLE(state[i][j])][LO_NIBBLE(state[i][j])];
        }
    }

    // test variable state
    printf("\n\n======================================\n\n");
    printf("After S-box Substitution:\n\n");
    int row, col;
    for (row=0; row&lt;4; row++){
        for (col=0; col&lt;4; col++){
            printf("state&lsqb;%d]&lsqb;%d] = \\x%02x\n", row, col, state[row][col]);
        }
    }

    return;
}

int main(){

    // Single state value for testing
    // stored by state[row][column]; so state[0][1] = 0x23
    uint8_t state[4][4] = { {0x01, 0x23, 0x45, 0x67},
			    {0x89, 0xab, 0xcd, 0xef},
			    {0xfe, 0xdc, 0xba, 0x98},
			    {0x76, 0x54, 0x32, 0x10}
			  };

    SubBytes(state);
    return 0;
}

												</code>
											</pre>

											<p>
												The most important concept of this section is having a test setup that will ensure success. &nbsp;Test cases are incredibly important as well since they validate
												working functions. &nbsp;<a href="https://kavaliro.com/wp-content/uploads/2014/03/AES.pdf" target="_blank" style="color:blue;">Encryption</a> and
												<a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf" target="_blank" style="color:blue;">decryption</a> (page 40) test values can be found their respective
												 links. &nbsp;The encryption link includes a test case for key expansion as well. &nbsp;For more complicated functions like <i>Inverse Mix Columns</i>, test cases can be found
												 <a href="http://www.infosecwriters.com/text_resources/pdf/AESbyExample.pdf" target="_blank" style="color:blue;">here</a> on page 8.<br>
												 &emsp; &emsp;Finally when in doubt, use print statements. &nbsp;Data visualization goes a long way when it comes to fault isolation. &nbsp;Sometimes the most difficult part of
												 debugging is figuring out the problem location and visualization helps tremendously.

											</p>

			<br><section id="Simple"><h2>Constructing the Simple Functions</h2></section>

										<p>
										&emsp; &emsp;Start coding in baby steps by constructing a word rotation function (<i>RotWord</i>) that takes four input bytes and rotates their positions
										one byte to the left. &nbsp;Note the leftmost byte, B<sub>0</sub>, wraps around to become the rightmost byte, B<sub>3</sub>. &nbsp;This is one of the sub-functions of <i>g()</i> in the
										key expansion algorithm.
										</p>
										<center><div class="image post"><img src="../images/slae/assignment7/6-rotword.png" alt="" /></div></center><br>

										<p>
										 &nbsp;It is important to note in C, individual bytes are
										handled using the <i>uint8_t</i> data type for "unsigned integer 8 bit." &nbsp;These integer types are defined in
										<a href="https://www.gnu.org/software/libc/manual/html_node/Integers.html" target="_blank" style="color:blue;"><i>stdint.h</i></a>
										so the header is required. &nbsp;In order for shifting to occur, the leftmost byte must be stored in a temporary location while the new positions are overwritten. &nbsp;Without
										 temporary storage, the leftmost byte will be overwritten and lost!<br>
										&emsp; &emsp;A simple outline is to declare a uint8_t emporary variable, <i>temp</i>, and assign it the leftmost byte. &nbsp;Assign the leftmost byte position the value of
										the next byte position. &nbsp;Once the rightmost position is reached, assign it the <i>temp</i> value. &nbsp;The resultant code is below!
										</p>
											<pre>
												<code class="c-like" style=display:block;white-space:pre-wrap>
// Rotates a 4-byte word to the left by 8 bits.
// Ex: w0 = [01, 23, 45, 67] ===> w0' = [23, 45, 67, 01]
void RotWord(uint8_t wordIn[]){

    // temporarily store first byte
    uint8_t temp = wordIn[0];

    // manually shift other bytes to the left 1 position. Place temporarily
    // stored byte into last position.
    wordIn[0] = wordIn[1];
    wordIn[1] = wordIn[2];
    wordIn[2] = wordIn[3];
    wordIn[3] = temp;

    return;
}

												</code>
											</pre>

											<p>
												Give <i>RotWord()</i> a test case similar to what is done in <a href="#Testing" style="color:blue;">Test Methodology</a>; however, the test value should
												be a single array of 4 bytes. &nbsp;Add a few cosmetic print statements to help with data visualization. &nbsp;A successful test result is shown below!
											</p>
											<center><div class="image post"><img src="../images/slae/assignment7/7-rotword-demo.png" alt="" /></div></center><br>

										<p>
											Repeat the process for <i>SubBytes</i>. &nbsp;This can be written to handle either 4x4 byte matrices or 4 byte arrays; both are required in this program. &nbsp;
											Refer to its code in <a href="#Testing" style="color:blue;">Test Methodology</a> above to find a couple gaps:<br>
											<ol>
												<li>Where is the sbox array? &nbsp;</li>
												<li>Where are <code>HI_NIBBLE</code> and <code>LO_NIBBLE</code> defined?</li>
											</ol>
											 &nbsp;Refer once again to
											<a href="https://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0134444280/ref=sr_1_2?dchild=1&keywords=ISBN+13%3A+978-1-292-15858-7&qid=1606786625&sr=8-2" target="_blank" style="color:blue;">Cryptography and Network Security 7th Edition</a>
											 on page 181 for the substitution boxes (S-boxes). &nbsp;The left four bits is the row lookup, and the right four bits is the column. &nbsp;These lookup tables are the heart of AES
											 algorithm and rely on finite field mathematics, specifically Galois Field (GF) over 2<sup>8</sup>. &nbsp;The tables can be derived by calculating the multiplicative
											 inverse over GF(2<sup>8</sup>), which is beyond the scope of this article. &nbsp;The S-boxes can be hardcoded in their own 16 x 16 byte matrices.
										</p>
											<center><div class="image post"><img src="../images/slae/assignment7/8-sbox.png" alt="" /></div></center><br>

										<p>
											Performing lookups on single bytes requires they be split apart. &nbsp;Performing this requires a couple definitions below. &nbsp;These definitions manipulate bit
											shifting and ANDing with 0x0F to ensure only appropraite values are returned. &nbsp;For example <code>HI_NIBBLE(0x01)</code> equals 0 and <code>LO_NIBBLE(0x23)</code> equals
											 3. &nbsp;These definitions ensure accurate S-box lookups for each value.
										</p>
											<pre>
												<code class="c-like" style=display:block;white-space:pre-wrap>
#define HI_NIBBLE(b) (((b) >> 4) & 0x0F)
#define LO_NIBBLE(b) ((b) & 0x0F)
												</code>
											</pre>

											<p>
												Nested for-loops are used to handle individual matrix elements. &nbsp;Compile and test function <i>SubBytes()</i> and manually verify the output by inspecting the S-box.
											</p>
										<center><div class="image post"><img src="../images/slae/assignment7/9-subbytes-works.png" alt="" /></div></center><br>

										<p>
											Shift rows is another relatively easy function to write and test. &nbsp;Start with <i>RotWord()</i> and expand it to handle a 16 byte state matrix.
											 &nbsp;Below is yet another example from
											 <a href="https://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0134444280/ref=sr_1_2?dchild=1&keywords=ISBN+13%3A+978-1-292-15858-7&qid=1606786625&sr=8-2" target="_blank" style="color:blue;">Cryptography and Network Security 7th Edition</a>
											  of how AES row shifting works on page 186. &nbsp;The first row is unchanged, the second row shifts left by one, the third row shifts left by two, and
											  the last row shifts left by three (or right by one).
										</p>
										<center><div class="image post"><img src="../images/slae/assignment7/10-shiftrows.png" alt="" /></div></center><br>

										<p>
											Basically take <i>RotWord()</i>, change its argument, and rotate the rows by their proper offsets. &nbsp;For optimization, <i>RotWord()</i> could include
											an integer parameter to express the number of positions to shift. &nbsp;If that is done, simply call <i>RotWord()</i> three times like this:
											<i>RotWord(w1, 1)</i>; <i>RotWord(w2, 2)</i>; <i>RotWord(w3, 3)</i>; &nbsp;Below is the final code for <i>ShiftRows()</i>.

										</p>
										<pre>
											<code class="c-like" style=display:block;white-space:pre-wrap>
// Cipher transformation that shifts last 3 rows by different offsets
void ShiftRows(uint8_t shiftedRows[4][4]){

	// Execute ShiftRows function per 'Ch06 Crypto7e.pdf' pg. 17
	int row;
	uint8_t temp, temp2;
	for (row = 0; row&lt;4; row++){
		if (row == 0) {
			// members are simply copied for first row
			shiftedRows[row][0] = shiftedRows[0][0];
			shiftedRows[row][1] = shiftedRows[0][1];
			shiftedRows[row][2] = shiftedRows[0][2];
			shiftedRows[row][3] = shiftedRows[0][3];
		}
		else if (row == 1) {
			temp = shiftedRows[row][0];
			// shift second row left 1 byte
			shiftedRows[row][0] = shiftedRows[1][1];
			shiftedRows[row][1] = shiftedRows[1][2];
			shiftedRows[row][2] = shiftedRows[1][3];
			shiftedRows[row][3] = temp;
		}
		else if (row == 2) {
			temp = shiftedRows[row][0];
			temp2 = shiftedRows[row][1];
			// shift third row left 2 bytes
			shiftedRows[row][0] = shiftedRows[2][2];
			shiftedRows[row][1] = shiftedRows[2][3];
			shiftedRows[row][2] = temp;
			shiftedRows[row][3] = temp2;
		}
		else {
			temp = shiftedRows[row][3];
			// shift fourth row left 3 bytes (or right 1 byte)
			shiftedRows[row][3] = shiftedRows[3][2];
			shiftedRows[row][2] = shiftedRows[3][1];
			shiftedRows[row][1] = shiftedRows[3][0];
			shiftedRows[row][0] = temp;
		}
	}

	return;
}
											</code>
										</pre>

										<p>
											Compile and run it with a test matrix to confirm functionality!
										</p>
										<center><div class="image post"><img src="../images/slae/assignment7/11-shiftrows-demo.png" alt="" /></div></center><br>

										<p>
											The final "easy" function is <i>Add round key</i>, which is a simple 1-to-1 XOR operation of two 16 byte matrices. &nbsp;For example in the below example,
											a<sub>2,2</sub> is XORed with b<sub>2,2</sub> and the result is stored in k<sub>2,2</sub>. &nbsp;This linear calculation happens 16 times to cover all bytes
											in the state matrix.
										</p>
										<center><div class="image post"><img src="../images/slae/assignment7/12-addroundkey.png" width="560"alt="" /></div></center><br>

										<p>
											Once again use nested for-loops to traverse all bytes of the state matrix. &nbsp;The resultant code is below.
										</p>
										<pre>
											<code class="c-like" style=display:block;white-space:pre-wrap>
// Cipher transformation in which a round key is added to the state using a XOR operation
void AddRoundKey(uint8_t state[4][4], uint8_t key[4][4]){

    // Simple 1-to-1 XOR operation
    int i, j;
    for (i = 0; i&lt;4; ++i){
        for (j = 0; j&lt;4; ++j) {
            state[i][j] ^= key[i][j];
        }
    }

    return;
}
											</code>
										</pre>

										<p>
											Compile and run the code using two test matrices. &nbsp;<a href="https://kavaliro.com/wp-content/uploads/2014/03/AES.pdf" target="_blank" style="color:blue;">Here</a>
											 is the test case on page 4.
										</p>
										<center><div class="image post"><img src="../images/slae/assignment7/13-addroundkey-demo.png" alt="" /></div></center><br>







			<br><section id="MixColumns"><h2>Mix Columns</h2></section>

									<p>
										&emsp; &emsp;Covering more difficult functions begins here and includes both <i>Mix columns</i> and its inverse function. &nbsp;According to Googlepedia,
										<i>Mix columns</i> is a four byte linear transformation in a GF(2<sup>8</sup>) finite field. &nbsp;The operation treats each group of bytes as coefficients
										of a polynomial over GF(2<sup>8</sup>) and reduced by the irreducible polynomial: x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1. &nbsp;Because of
										that finite field property, the multiplication must check if the leftmost byte is 1 and subsequently XOR by x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup>
										 + x + 1. &nbsp;Below are the derived constant matrices for both <i>MixColumns()</i> and <i>InvMixColumns()</i> courtesy of this
										<a href="https://www.semanticscholar.org/paper/Area-Optimized-Architecture-for-AES-Mix-Column-Shaji-BonifusP./385db46392682b99e72f822cb291986fb112009d/figure/2" target="_blank" style="color:blue;">Semantic Scholar paper</a>.
										 &nbsp;These will be known as 'mixer' and 'inverse_mixer' from now on.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/14-mixcolumns-matrices.png" alt="" /></div></center><br>

									<p>
										Below is an example of matrix multiplication specific to <i>MixColumns</i> (<a href="https://www.angelfire.com/biz7/atleast/mix_columns.pdf" target="_blank" style="color:blue;">source</a>).
 									Standard matrix multiplication applies so <code>0x04 = (0x02)(0xd4) + (0x03)(0xbf) + (0x01)(0x5d) + (0x01)(0x30)</code> and <br>
									<code>0x66 = (0x01)(0xd4) + (0x02)(0xbf) + (0x03)(0x5d) + (0x01)(0x30)</code>.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/15-mixcolumns.png" width="500" alt="" /></div></center><br>

									<p>
										Since <i>MixColumns()</i> operates on a 4x4 state matrix, it must make an additional iteration over columns. &nbsp;Not only would it iterate again, the
										function must remember the original index to place the result. &nbsp;Luckily there is a freely available
										<a href="https://www.programiz.com/c-programming/examples/matrix-multiplication" target="_blank" style="color:blue;">template</a> to start with! &nbsp;The
										 template's implementation ensures sub-calculations are added to the target location each iteration. &nbsp;For example, the operation
										 (0x01)(0xd4) above is calculated and stored in the 0x04 spot before continuing with (0x02)(0xbf). &nbsp;(0x02)(0xbf) is then calculated and added
										 to the (0x01)(0xd4) result. &nbsp;Luckily the bitwise XOR and assignment operator <code>^=</code> handles this task since XOR is additive! &nbsp;Just
										 make sure the result matrix is initialized to zero beforehand.<br>
										&emsp; &emsp;Different implementations must be handled when multiplying by each number in mixer (0x01, 0x02, or 0x03). &nbsp;If the multiplied
										 number from mixer is 0x01, simply multiply it with the state matrix value and store it into its result matrix spot. &nbsp;Things get interesting when
										 multiplying by 0x02 or 0x03. &nbsp;Revisiting the finite field property, a simple bitwise left shift will mutliply a byte by two; however, it must also be XORed with
										 0x1b if the leftmost bit is 1. &nbsp;0x1b is the bitwise expression of the irreducible polynomial x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1.
										  &nbsp;All of this can be handled using if-statements and checking for a high nibble greater than 0x8. &nbsp;Perform the same check when 0x03 is
										  multiplied. &nbsp;The only addition is XORing the result with the state value one more time to get a multiplication of 0x03. &nbsp;Below is the resultant code.


									</p>
									<pre>
										<code class="c-like" style=display:block;white-space:pre-wrap>
uint8_t mixer[4][4] = { {0x02, 0x03, 0x01, 0x01},
			{0x01, 0x02, 0x03, 0x01},
			{0x01, 0x01, 0x02, 0x03},
			{0x03, 0x01, 0x01, 0x02}
		      };

// Cipher transformation that takes all of the columns of the state and mixes their data to produce new columns
void MixColumns(uint8_t state[4][4]){
    // Execute MixColumns function per source: `angelfire.com/biz7/atleast/mix_columns.pdf`
    // character '<<' means left shift by x bits
    int i, j, k;
    uint8_t result[4][4] = { 0 };
    for (i = 0; i&lt;4; ++i){
        for (j = 0; j&lt;4; ++j) {
            for (k = 0; k&lt;4; ++k){
                // Iterate over COLUMNS in state, while iterating by Mixer ROWS on the outside loop
                // hence mixer[i][k] and state[k][j]
                if (mixer[i][k] == 0x01){
                    // Do normal multiplication (0x01 * column value)
                    result[i][j] ^= mixer[i][k]*state[k][j];
                }
                else if (mixer[i][k] == 0x02){
                    // slightly more complicated instructions
                    // left shift state[i][j] value 1 byte then XOR with 0x1b if leftmost bit is 1
                    // source: `cs.purdue.edu/homes/ssw/cs655/rij.pdf`
                    if (HI_NIBBLE(state[k][j]) >= 8){
                        result[i][j] ^= (state[k][j] &lt;&lt;1) ^ 0x1b;
                    }
                    else {
                        result[i][j] ^= (state[k][j] &lt;&lt; 1);
                    }
                }
                else {
                    // Same instructions as mixer[j][i] == 0x02 with an additional XOR of state[k][j]
                    if (HI_NIBBLE(state[k][j]) >= 8){
                        result[i][j] ^= (state[k][j] &lt;&lt;1) ^ 0x1b;
                    }
                    else {
                        result[i][j] ^= (state[k][j] &lt;&lt; 1);
                    }
                    result[i][j] ^= state[k][j];
                } // end else
            } // end k
        } // end j
    } // end i

    // Store all results back into state matrix
    int row, col;
    for (row=0; row&lt;4; row++){
        for (col=0; col&lt;4; col++){
            state[row][col] = result[row][col];
        }
    }

    return;
}
										</code>
									</pre>

									<p>
									Compile and validate the function using <a href="https://kavaliro.com/wp-content/uploads/2014/03/AES.pdf" target="_blank" style="color:blue;">this</a> test
									case on page 7.
								</p>

									<center><div class="image post"><img src="../images/slae/assignment7/16-mixcolumns-demo.png" alt="" /></div></center><br>

									<p>
										Inverse Mix columns operates the same way although a small challenge is presented: the numbers to multiply with are much larger
										(0x09, 0x0b, 0x0d, and 0x0e). &nbsp;Luckily
										<a href="http://www.infosecwriters.com/text_resources/pdf/AESbyExample.pdf" target="_blank" style="color:blue;">InfosecWriters</a> published
										a couple tables on page 8 to help multiply over finite fields. &nbsp;These lookup tables similar to the S-boxes above. &nbsp;For each value being multiplied,
										perform an L[][] lookup on them then add together. &nbsp;Once added together, perform an E[][] lookup on the result and <code>^=</code> it to the target
										position. &nbsp;Iterate over the matrix indeces the same way in <i>MixColumns()</i>. &nbsp;If an encrypted byte passed into L[][] is 0x00, then it is
										equivalent to multiplying by 0. &nbsp;Simply XOR the result with 0x00. &nbsp;Below is the final code.
									</p>
									<pre>
										<code class="c-like" style=display:block;white-space:pre-wrap>
uint8_t inverse_mixer[4][4] = { {0x0e, 0x0b, 0x0d, 0x09},
				{0x09, 0x0e, 0x0b, 0x0d},
				{0x0d, 0x09, 0x0e, 0x0b},
				{0x0b, 0x0d, 0x09, 0x0e}
			      };

// Cipher transformation that takes all of the columns of the state and mixes their data to produce new columns
void InvMixColumns(uint8_t state[4][4]){

    // Execute Inverse MixColumns function per source: `http://infosecwriters.com/text_resources/pdf/AESbyExample.pdf` pgs. 8-9
    int i, j, k;
    uint8_t result[4][4] = { 0 };
    uint8_t L_state, L_invmixer, byte;

    for (i = 0; i&lt;4; ++i){
        for (j = 0; j&lt;4; ++j) {
            for (k = 0; k&lt;4; ++k) {
                /* Iterate over COLUMNS in state, while iterating by inverse_mixer ROWS on the outside loop
                hence inverse_mixer[i][k] and state[k][j]
                Matrix multiplication is more complicated in inverse MixColumns.  That is why lookup tables
                E and L are used to represent Galois Field finite field multiplication
                */

                // Handle multiplication instance for a null byte in state[k][j]; There are no NULL bytes in inverse_mixer
                if (state[k][j] == 0x00){
                    result[i][j] ^= 0x00;
                }
                else {

                    // First stage results from L lookup table over GF2
                    L_state = L[HI_NIBBLE(state[k][j])][LO_NIBBLE(state[k][j])];
                    L_invmixer = L[HI_NIBBLE(inverse_mixer[i][k])][LO_NIBBLE(inverse_mixer[i][k])];

                    // Check if byte overflow occurs when summing L_state and L_invmixer. Subtract 0xff if overflow occurs.
                    if (L_state + L_invmixer > 0xff) {
                        byte = L_state + L_invmixer - 0xff;
                    }
                    else {
                        // else do normal byte addition
                        byte = L_state + L_invmixer;
                    }

                    // Add E-lookup result into temporary state matrix
                    result[i][j] ^= E[HI_NIBBLE(byte)][LO_NIBBLE(byte)];

                } // end normal else statement

            } // end k
        } // end j
    } // end i

    // Store all results back into state matrix
    int row, col;
    for (row=0; row&lt;4; row++){
        for (col=0; col&lt;4; col++){
            state[row][col] = result[row][col];
        }
    }

    return;
}

										</code>
									</pre>

									<p>
										Use the highlighted test values below from <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf" target="_blank" style="color:blue;">NIST FIPS 197</a>
										page 37 as the input state matrix.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/17-invmixcolumns-test.png" alt="" /></div></center><br>

									<p>
										Compile and run to verify the output matches the start of round 2 values above.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/18-invmixcolumns-demo.png" alt="" /></div></center><br>



			<br><section id="ExpandKey"><h2>Key Expansion</h2></section>
			<!--
			OBJDUMP Special Command:
			objdump -d ./PROGRAM|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'
			-->
									<p>
										&emsp; &emsp;Key expansion consists of using the earlier "easy" functions as building blocks; however, these functions are only used on every
										fourth word. &nbsp;More logic must be built out in key expansion to handle all other words. &nbsp;Below is the algorithm from the most reliable source,
										<a href="https://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0134444280/ref=sr_1_2?dchild=1&keywords=ISBN+13%3A+978-1-292-15858-7&qid=1606786625&sr=8-2" target="_blank" style="color:blue;">Cryptography and Network Security 7th Edition</a>
										 from page 191.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/19-keyexpansion-algorithm.png" alt="" /></div></center><br>

									<p>
									Because this is AES-128 bit, the first four words of the key are simply the first 16 bytes of the user provided key. &nbsp;This assignment is easy
									and is handled with a simple XOR operation looping over the words. &nbsp;Words 4 to 44 require an XOR of the previous word and its [i - 4] indexed
									word. &nbsp;Because of the special function implemented every fourth word, the previous word must be stored in a temporary word regardless.
									 &nbsp;Checking every fourth word is handled by a modulo operation in an if-statement allowing the program to branch to the <i>g()</i> function.
									  &nbsp;Call <i>RotWord()</i> and <i>SubWord()</i> in order then XOR with the round constant mapped by <i>Rcon[i/4]</i>. &nbsp;Rcon is an array
									  of round constants expresssed as "the exponentiation of 2 to a user-specified value" over a finite field
									  (<a href="https://cryptography.fandom.com/wiki/Rijndael_key_schedule" target="_blank" style="color:blue;">source</a>). &nbsp;Its definition can
									  be copied from the source but only the first 11 values are needed. &nbsp;Below is the AES-128 implementation of <i>ExpandKey()</i>. &nbsp;Further
									  changes must be made if working with AES-256 such as 60 words, up to 32 bytes of user provided key in the first eight words, and implementing key
									  padding standards should the input key not be 32 bytes long.
									</p>

									<pre>
										<code class="c-like" style=display:block;white-space:pre-wrap>

// Cipher transformation that takes all of the columns of the state and mixes their data to produce new columns
// Algorithm source: `brainkart.com/article/AES-Key-Expansion_8410/`
void ExpandKey(uint8_t key[4][4], uint8_t word[44][4]){

    int i, j, k;
    uint8_t temp[4];

    // First 4 words of expanded key are just the key copied
    for (i = 0; i&lt;4; ++i) {
        for (j=0; j&lt;4; j++) {
            word[j][i] ^= key[i][j];
        }
    }

    // Handle remaining words of key expansion
    for (i = 4; i&lt;44; i++) {
        for (j = 0; j&lt;4; j++) {
            // Copy previous word into temporary location
            temp[j] = word[i - 1][j];
        }

        // for every fourth word, execute g(word[]) operation
        if (i % 4 == 0) {
            RotWord(temp);
            SubWord(temp);
            temp[0] ^= Rcon[i/4];
        }

        // At i = 4, w[4] = w[0] ^ g(w[3])
        for (k=0; k&lt;4; k++){
            // word[4][k] = word[0][k] XOR temp[k]
            word[i][k] = word[i - 4][k] ^ temp[k];
        }
    } // end i

} // end ExpandKey()
										</code>
									</pre>

									<p>
									Compile and run using the <a href="https://kavaliro.com/wp-content/uploads/2014/03/AES.pdf" target="_blank" style="color:blue;">test case</a> on
									pages 2 and 3. &nbsp;Test output is much too long to display but values match results on page 3.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/20-keyexpansion-demo.png" alt="" /></div></center><br>



			<br><section id="Cipher"><h2>Cipher Repetitions</h2></section>

									<p>
										&emsp; &emsp;Return to the <a href="https://thestunneddefense.com/pages/custom-crypter.html#Outline" target="_blank" style="color:blue;">system outline</a>
										 once all subfunctions have been written and tested. &nbsp;Encryption and decryption functions must occur in an iterated fashion according to the
										 outline. &nbsp;Furthermore, these rounds all happen on 16 byte blocks of data at a time. &nbsp;This means another function is required to implement encryption
										 rounds for every 16 bytes of data that gets encrypted.<br>
										 &emsp; &emsp;Before any encryption rounds happen, <i>AddRoundKey()</i> is called with the first four words of the key schedule. &nbsp;Then functions
										 <i>SubBytes()</i>, <i>ShiftRows()</i>, <i>MixColumns()</i>, and <i>AddRoundKey()</i> are called in a row nine times. &nbsp;The tenth round omits
										 <i>MixColumns()</i>.
									</p>
									<pre>
										<code class="c-like" style=display:block;white-space:pre-wrap>
// Main cipher function that calls sub-functions in order: SubBytes(), ShiftRows(), MixColumns(), and AddRoundKey()
// RoundKey is produced in the key expansion function, ExpandKey(),
void Cipher(uint8_t state[4][NB], uint8_t keySchedule[44][NB]){
    /*
        Cipher function performs the actual encryption operations on 16-byte blocks
        of plaintext and keys.

        plaintext matrix is already set (from state[][]) but Key Expansion must take
        place in ExpandKey(). Round keys are loaded into inputKey[4][4] one round at a time.
    */

    // Load first 4 words of keySchedule[][] for use with AddRoundKey()
    uint8_t inputKey[4][4] = { 0 };
    int a, b;
    for (a = 0; a&lt;4; a++) {
        for (b = 0; b&lt;4; b++) {
            inputKey[b][a] = keySchedule[a][b];
        }
    }

	// Call first instance of AddRoundKey() before continuing with normal rounds
	AddRoundKey(state, inputKey);

    // Perform encryption rounds
    // Call SubBytes(), ShiftRows(), MixColumns(), and AddRoundKey() 13 times
    for (int i = 1; i &lt; NR; i++) {

        SubBytes(state);
        ShiftRows(state);
        MixColumns(state);


        // Load round key from keySchedule for use in AddRoundKey
        int row, col;
        for (row = i*NB; row&lt;(i*NB)+4; row++) {
            for (col = 0; col&lt;4; col++) {
                inputKey[col][row - (i*NB)] = keySchedule[row][col];
            }
        }

            // This index should be a multiple of 4 increasing from 4 up to 40
            AddRoundKey(state, inputKey);

    } // end round iterations loop

    // Omit MixColumns() for final round; else proceed with SubBytes(),
    // ShiftRows(), and AddRoundKey() in order
    SubBytes(state);
    ShiftRows(state);

    // Load last 4 words from keySchedule for final AddRoundKey
    int c, d;
    for (c = 40; c&lt;44; c++) {
        for (d = 0; d&lt;4; d++) {
            inputKey[d][c-40] = keySchedule[c][d];
        }
    }
    // 40 is the starting index of last 4 words: 40, 41, 42, 43
    AddRoundKey(state, inputKey);

    return;
} // end Cipher function
										</code>
									</pre>


									<center><div class="image post"><img src="../images/slae/assignment7/.png" alt="" /></div></center><br>



			<br><section id="Integration"><h2>Integration and Demonstration</h2></section>

									<p>


									</p>
									<center><div class="image post"><img src="../images/slae/assignment7/.png" alt="" /></div></center><br>



		<br><section id="Thoughts"><h2>Thoughts and Lessons Learned</h2></section>

									<p>
										&emsp; &emsp;Conclusion goes here
									</p>
									<!--<center><div class="image post"><img src="../images/slae/assignment7/.png" alt="" /></div></center><br>-->





									<p>
										The source code for this assignment as well as other SLAE assignments is here:
										<a href="https://github.com/jpc0016/SLAE-code" target="_blank" style="color:blue;">https://github.com/jpc0016/SLAE-code</a>
									</p>

									<p>
									This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:
									<a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/" target="_blank" style="color:blue;">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/</a><br>

									Student ID: PA-15981
									</p>


                        </div>

                      </article>
                    </body>
                  </section>








									<!--
									End post body
									-->

									<!--
									NEW POSTS GO ABOVE THIS LINE
									-->






									<!-- Remove Pagination
							<div class="pagination"><a href="#"> 1 </a></div>
							<div class="pagination"><a href="#"> 2 </a></div>
							<div class="pagination"><a href="#"> 3 </a></div>
							<div class="pagination"><a href="#"> 4 </a></div>
							<div class="pagination"><a href="#"> 5 </a></div>-->
							</div>
					</div>

				<!-- Footer -->
					<footer id="footer">

						<section class="split contact">

							<section>
								<h3>Social</h3>
								<ul class="icons alt">
									<li><a href="mailto:jpc0016@uah.edu" class="icon fa-paper-plane-o" target="_blank"><span class="label">Gmail</span></a></li>
									<li><a href="https://github.com/jpc0016" class="icon fa-github" target="_blank"><span class="label">GitHub</span></a></li>
									<li><a href="https://twitter.com/JohnGuy_01" class="icon fa-twitter" target="_blank"><span class="label">Twitter</span></a></li>
									<li><a href="https://stackoverflow.com/users/11770689/jpc0016?tab=profile" class="icon fa-stack-overflow" target="_blank"><span class="label">StackOverflow</span></a></li>
								</ul>
							</section>
						</section>
					</footer>

				<!-- Copyright -->
					<div id="copyright">
						<ul><li>&copy; Untitled</li><li>Design: <a href="https://html5up.net" target="_blank">HTML5 UP</a></li></ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
